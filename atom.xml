<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
    <id>https://2050188619.github.io</id>
    <title>Peaky</title>
    <updated>2021-07-21T12:08:48.409Z</updated>
    <generator>https://github.com/jpmonette/feed</generator>
    <link rel="alternate" href="https://2050188619.github.io"/>
    <link rel="self" href="https://2050188619.github.io/atom.xml"/>
    <subtitle>温故而知新</subtitle>
    <logo>https://2050188619.github.io/images/avatar.png</logo>
    <icon>https://2050188619.github.io/favicon.ico</icon>
    <rights>All rights reserved 2021, Peaky</rights>
    <entry>
        <title type="html"><![CDATA[# 第1天 SpringCloud]]></title>
        <id>https://2050188619.github.io/post/di-1-tian-springcloud/</id>
        <link href="https://2050188619.github.io/post/di-1-tian-springcloud/">
        </link>
        <updated>2021-07-21T12:07:03.000Z</updated>
        <summary type="html"><![CDATA[<h1 id="第1天-springcloud">第1天 SpringCloud</h1>
<h2 id="学习目标">学习目标</h2>
<ul>
<li>
<p>能够理解SpringCloud作用</p>
<ul>
<li>用来做微服务架构的技术解决方案</li>
<li><mark>SpringCloud基于SpringBoot开发的，SpringCloud整合了很多优秀的第三方微服务开源框架</mark></li>
</ul>
</li>
<li>
<p>能够使用RestTemplate发送请求</p>
<ul>
<li>封装了基于Rest的Http请求[实现Http请求]</li>
<li>可以实现Java对象序列化与反序列化[序列化与反序列化]</li>
</ul>
</li>
<li>
<p><mark>能够搭建Eureka注册中心</mark></p>
<ul>
<li>用于管理服务、监控服务、服务路由</li>
</ul>
</li>
<li>
<p>项目注册:服务提供者注册、服务消费者注册、Eureka注册中心(Zookeeper)</p>
</li>
<li>
<p>能够使用<mark>Ribbon负载均衡</mark></p>
<ul>
<li>用来实现负载均衡(实现消费方负载均衡)</li>
</ul>
</li>
<li>
<p>能够使用<mark>Hystrix</mark>熔断器</p>
<ul>
<li>做服务降级，防止程序发生雪崩</li>
</ul>
</li>
</ul>
<h2 id="1-初识spring-cloud">1 初识Spring Cloud</h2>
<p>大家谈起的微服务，大多来讲说的只不过是种架构方式。其实现方式很多种：Spring Cloud，Dubbo，华为的Service Combo，Istio 。</p>
<p>那么这么多的微服务架构产品中，我们为什么要用Spring Cloud？因为它后台硬、技术强、群众基础好，使用方便；</p>
<h3 id="11-目标">1.1 目标</h3>
<ul>
<li>了解微服务架构</li>
<li>了解SpringCloud技术</li>
</ul>
<h3 id="12-讲解">1.2 讲解</h3>
<h4 id="121-技术架构演变">1.2.1 技术架构演变</h4>
<p>(1)单一应用架构</p>
<p>当网站流量很小时，只需要一个应用，所有功能部署在一起，减少部署节点成本的框架称之为集中式框架。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。</p>
<figure data-type="image" tabindex="1"><img src="images%5C1563128795202.png" alt="1563128795202" loading="lazy"></figure>
<p>(2)垂直应用架构</p>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<figure data-type="image" tabindex="2"><img src="images%5C1563128890388.png" alt="1563128890388" loading="lazy"></figure>
<p>(3)分布式服务架构</p>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<figure data-type="image" tabindex="3"><img src="images%5C1563129132684.png" alt="1563129132684" loading="lazy"></figure>
<p>(4)面向服务(SOA)架构</p>
<p>典型代表有两个：流动计算架构和微服务架构；</p>
<p><strong>流动计算架构：</strong></p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。流动计算架构的最佳实践阿里的Dubbo。</p>
<p><strong>微服务架构</strong></p>
<p>与流动计算架构很相似，除了具备流动计算架构优势外，微服务架构中的微服务可以独立部署，独立发展。且微服务的开发不会限制于任何技术栈。微服务架构的最佳实践是SpringCloud。</p>
<figure data-type="image" tabindex="4"><img src="images%5C1563128667644.png" alt="1563128667644" loading="lazy"></figure>
<h4 id="122-springcloud简介">1.2.2 SpringCloud简介</h4>
<p>(1)SpringCloud介绍</p>
<p>Spring Boot擅长的是集成，把世界上最好的框架集成到自己项目中</p>
<p><mark>Spring Cloud本身也是基于SpringBoot开发而来，SpringCloud是一系列框架的有序集合,也是把非常流行的微服务的技术整合到一起，是属于微服务架构的一站式技术解决方案。</mark></p>
<p>Spring Cloud包含了：</p>
<p>注册中心：<mark>Eureka、consul</mark>、Zookeeper</p>
<p>负载均衡：Ribbon</p>
<p>熔断器：Hystrix</p>
<p>服务通信：Feign</p>
<p>网关：Gateway</p>
<p>配置中心 ：config</p>
<p>消息总线：Bus</p>
<p>集群状态等等....功能。</p>
<p>Spring Cloud协调分布式环境中各个微服务，为各类服务提供支持。</p>
<figure data-type="image" tabindex="5"><img src="images%5C1555072329184.png" alt="" loading="lazy"></figure>
<p>(2)Spring Cloud的版本</p>
<figure data-type="image" tabindex="6"><img src="images%5C1563019084631.png" alt="1563019084631" loading="lazy"></figure>
<p>版本说明：</p>
<pre><code class="language-properties">SpringCloud是一系列框架组合，为了避免与框架版本产生混淆，采用新的版本命名方式，形式为大版本名+子版本名称
  大版本名用伦敦地铁站名
  子版本名称三种
    SNAPSHOT：快照版本，尝鲜版，随时可能修改
    M版本，MileStone，M1表示第一个里程碑版本，一般同时标注PRE，表示预览版
    SR，Service Release，SR1表示第一个正式版本，同时标注GA(Generally Available)，稳定版
</code></pre>
<p>(3)SpringCloud与SpringBoot版本匹配关系</p>
<table>
<thead>
<tr>
<th>SpringBoot</th>
<th>SpringCloud</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.2.x</td>
<td>Angel版本</td>
</tr>
<tr>
<td>1.3.x</td>
<td>Brixton版本</td>
</tr>
<tr>
<td>1.4.x</td>
<td>Camden版本</td>
</tr>
<tr>
<td>1.5.x</td>
<td>Dalston版本、Edgware</td>
</tr>
<tr>
<td>2.0.x</td>
<td>Finchley版本</td>
</tr>
<tr>
<td>2.1.x</td>
<td>Greenwich GA版本 (2019年2月发布)</td>
</tr>
</tbody>
</table>
<p>鉴于SpringBoot与SpringCloud关系，SpringBoot建议采用2.1.x版本</p>
<h3 id="13-小结">1.3 小结</h3>
<ul>
<li>微服务架构：就是将相关的功能独立出来，单独创建一个项目，并且连数据库也独立出来，单独创建对应的数据库。本质：将相关独立的业务完全独立出来，对应的工程和数据库也完全独立出来。</li>
<li>Spring Cloud本身也是基于SpringBoot开发而来，SpringCloud是一系列框架的有序集合,把非常流行的微服务的技术整合到了一起。</li>
</ul>
<h2 id="2-服务调用方式">2 服务调用方式</h2>
<h3 id="21-目标">2.1 目标</h3>
<ul>
<li>理解RPC和HTTP的区别</li>
<li>能使用RestTemplate发送请求(发送Http请求)</li>
</ul>
<h3 id="22-讲解">2.2 讲解</h3>
<h4 id="221-rpc和http">2.2.1 RPC和HTTP</h4>
<p>常见远程调用方式：</p>
<p>RPC:(Remote Produce Call)远程过程调用</p>
<pre><code class="language-properties">1.基于Socket
2.自定义数据格式
3.速度快，效率高
4.典型应用代表：Dubbo，WebService，ElasticSearch集群间互相调用
</code></pre>
<p>HTTP：网络传输协议</p>
<pre><code class="language-properties">1.基于TCP/IP
2.规定数据传输格式
3.缺点是消息封装比较臃肿、传输速度比较慢
4.优点是对服务提供和调用方式没有任何技术限定，自由灵活，更符合微服务理念
</code></pre>
<p>RPC和HTTP的区别：RPC是根据语言API来定义，而不是根据基于网络的应用来定义。</p>
<p>Http客户端工具</p>
<p>常见Http客户端工具：HttpClient(发送Http请求)、OKHttp(发送Http请求)、URLConnection(发送Http请求)。</p>
<h4 id="222-spring的resttemplate">2.2.2 Spring的RestTemplate</h4>
<p>(1)RestTemplate介绍</p>
<ul>
<li>RestTemplate是Rest的HTTP客户端模板工具类</li>
<li>对基于Http的客户端进行封装</li>
<li>实现对象与JSON的序列化与反序列化(JSON&lt;-&gt;JavaBean)</li>
<li>不限定客户端类型，目前常用的3种客户端都支持：HttpClient、OKHttp、JDK原生URLConnection(默认方式)</li>
</ul>
<p>(2)RestTemplate入门案例</p>
<figure data-type="image" tabindex="7"><img src="images%5C1563020200215.png" alt="1563020200215" loading="lazy"></figure>
<p>我们可以使用RestTemplate实现上图中的请求，<code>springcloud-day1-resttemplate</code>通过发送请求，请求<code>springcloud-day1-provider</code>的<code>/user/list</code>方法。</p>
<p>(1)搭建<code>springcloud-day1-provider</code></p>
<p>这里不演示详细过程了，大家直接使用IDEA搭建一个普通的SpringBoot工程即可。</p>
<p>坐标</p>
<pre><code class="language-xml">&lt;groupId&gt;com.itheima&lt;/groupId&gt;
&lt;artifactId&gt;springcloud-day1-provider&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
</code></pre>
<p>pom.xml依赖</p>
<pre><code class="language-xml">&lt;!--父工程--&gt;
&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
	&lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
	&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
	&lt;!--web起步依赖--&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>创建<code>com.itheima.domain.User</code></p>
<pre><code class="language-java">public class User implements Serializable {
    private String name;
    private String address;
    private Integer age;

    public User() {
    }

    public User(String name, String address, Integer age) {
        this.name = name;
        this.address = address;
        this.age = age;
    }
    //..get set toString 略
}
</code></pre>
<p>application.properties</p>
<pre><code class="language-properties">server.port=18081
</code></pre>
<p>创建<code>com.itheima.controller.UserController</code>,代码如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(value = &quot;/user&quot;)
public class UserController {

    /***
     * 提供服务
     * @return
     */
    @RequestMapping(value = &quot;/list&quot;)
    public List&lt;User&gt; list(){
        List&lt;User&gt; users = new ArrayList&lt;User&gt;();
        users.add(new User(&quot;王五&quot;, &quot;深圳&quot;, 25));
        users.add(new User(&quot;李四&quot;, &quot;北京&quot;, 23));
        users.add(new User(&quot;赵六&quot;, &quot;上海&quot;, 26));
        return users;
    }
}
</code></pre>
<p>创建启动类，并启动工程</p>
<pre><code class="language-java">@SpringBootApplication
public class SpringcloudDay1ProviderApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringcloudDay1ProviderApplication.class, args);
	}
}
</code></pre>
<p>访问：<code>&lt;http://localhost:18081/user/list&gt;</code>效果如下：</p>
<figure data-type="image" tabindex="8"><img src="images%5C1563020871025.png" alt="1563020871025" loading="lazy"></figure>
<p>(2)创建<code>springcloud-day1-resttemplate</code></p>
<p>创建的详细过程也不讲解了，直接使用IDEA创建一个SpringBoot工程即可。</p>
<p>pom.xml依赖</p>
<pre><code class="language-xml">&lt;!--父工程--&gt;
&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
	&lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
	&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
	&lt;!--web起步依赖--&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
	&lt;/dependency&gt;

	&lt;!--测试包--&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>创建启动类，并在启动类中创建RestTemplate对象</p>
<pre><code class="language-java">@SpringBootApplication
public class SpringcloudDay1ResttemplateApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringcloudDay1ResttemplateApplication.class, args);
	}

	/***
	 * @Bean:创建一个对象实例，并将对象交给Spring容器管理
	 * &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot; /&gt;
	 * @return
	 */
	@Bean
	public RestTemplate restTemplate(){
		return  new RestTemplate();
	}
}
</code></pre>
<p>测试</p>
<p>在测试类HttpDemoApplicationTests中<code>@Autowired</code>注入RestTemplate</p>
<p>通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码</p>
<p>RestTemplate会自动发起请求，接收响应</p>
<p>并且帮我们对响应结果进行反序列化</p>
<p>代码如下：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringcloudDay1ResttemplateApplicationTests {
	@Autowired
	private RestTemplate restTemplate;

	/**
	 * RestTemplate远程调用
	 */
	@Test
	public void testRestTemplateQuery() {
		String url = &quot;http://localhost:18081/user/list&quot;;
		String result = restTemplate.getForObject(url, String.class);
		System.out.println(result);
	}
}
</code></pre>
<p>运行测试方法，效果如下：</p>
<figure data-type="image" tabindex="9"><img src="images%5C1563021138586.png" alt="1563021138586" loading="lazy"></figure>
<h3 id="23-小结">2.3 小结</h3>
<ul>
<li>
<p>RPC和HTTP的区别：RPC是根据语言API来定义，而不是根据基于网络的应用来定义。</p>
</li>
<li>
<p>RestTemplate:</p>
<p>①RestTemplate是Rest的HTTP客户端模板工具类。</p>
<p>②对基于Http的客户端进行封装。</p>
<p>③实现对象与JSON的序列化与反序列化。</p>
<p>④不限定客户端类型</p>
</li>
<li>
<p>RestTemplate的使用</p>
<pre><code class="language-properties">创建一个RestTemplate，将该对象实例给SpringIOC容器管理
@Bean
public RestTemplate restTemplate(){
    return new RestTemplate();
}

restTemplate.getForObject(url,String.class);
</code></pre>
</li>
</ul>
<h2 id="3-模拟微服务业务场景">3 模拟微服务业务场景</h2>
<p>模拟开发过程中的服务间关系。抽象出来，开发中的微服务之间的关系是生产者和消费者关系。</p>
<p><strong>总目标：模拟一个最简单的服务调用场景，场景中保护微服务提供者(Producer)和微服务调用者(Consumer)</strong>，方便后面学习微服务架构</p>
<p><strong>注意：实际开发中，每个微服务为一个独立的SpringBoot工程。</strong></p>
<figure data-type="image" tabindex="10"><img src="images%5C1563027834881.png" alt="1563027834881" loading="lazy"></figure>
<h3 id="31-目标">3.1 目标</h3>
<ul>
<li>
<p>创建父工程</p>
</li>
<li>
<p>搭建服务提供者</p>
</li>
<li>
<p>搭建服务消费者</p>
</li>
<li>
<p>服务消费者使用RestTemplate调用服务提供者</p>
</li>
</ul>
<h3 id="32-讲解">3.2 讲解</h3>
<h4 id="321-创建父工程">3.2.1 创建父工程</h4>
<p>(1)新建工程</p>
<p>新建一个Maven父工程<code>springcloud-parent</code>,创建步骤如下：</p>
<figure data-type="image" tabindex="11"><img src="images%5C1563027911022.png" alt="1563027911022" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="images%5C1563027956557.png" alt="1563027956557" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="images%5C1563027999119.png" alt="1563027999119" loading="lazy"></figure>
<p>（2）引入依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;user-provider&lt;/module&gt;
        &lt;module&gt;user-consumer&lt;/module&gt;
    &lt;/modules&gt;

    &lt;!--父工程--&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
    &lt;/parent&gt;
    &lt;!--SpringCloud包依赖管理--&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Greenwich.SR1&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre>
<h4 id="322-创建服务提供者producer工程">3.2.2 创建服务提供者(producer)工程</h4>
<p>每个微服务工程都是独立的工程，连数据库都是独立的，所以我们一会要单独为该服务工程创建数据库。</p>
<p>工程创建步骤：</p>
<pre><code class="language-properties">1.准备表结构
2.创建工程
3.引入依赖
4.创建Pojo，需要配置JPA的注解
5.创建Dao，需要继承JpaRepository&lt;T,ID&gt;
6.创建Service，并调用Dao
7.创建Controller，并调用Service
8.创建application.yml文件
9.创建启动类
10.测试
</code></pre>
<p>(1)建表</p>
<p>producer工程是一个独立的微服务，一般拥有独立的controller、service、dao、数据库，我们在springcloud数据库新建表结构信息，如下：</p>
<pre><code class="language-sql">-- 使用springcloud数据库
USE springcloud;
-- ----------------------------
-- Table structure for tb_user
-- ----------------------------
CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(100) DEFAULT NULL COMMENT '用户名',
  `password` varchar(100) DEFAULT NULL COMMENT '密码',
  `name` varchar(100) DEFAULT NULL COMMENT '姓名',
  `age` int(11) DEFAULT NULL COMMENT '年龄',
  `sex` int(11) DEFAULT NULL COMMENT '性别，1男，2女',
  `birthday` date DEFAULT NULL COMMENT '出生日期',
  `created` date DEFAULT NULL COMMENT '创建时间',
  `updated` date DEFAULT NULL COMMENT '更新时间',
  `note` varchar(1000) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='用户信息表';
-- ----------------------------
-- Records of tb_user
-- ----------------------------
INSERT INTO `tb_user` VALUES ('1', 'zhangsan', '123456', '张三', '13', '1', '2006-08-01', '2019-05-16', '2019-05-16', '张三');
INSERT INTO `tb_user` VALUES ('2', 'lisi', '123456', '李四', '13', '1', '2006-08-01', '2019-05-16', '2019-05-16', '李四');
</code></pre>
<p>(2)新建user-provider工程</p>
<p>选中springcloud-parent工程-&gt;New Modul-&gt;Maven-&gt;输入坐标名字，如下步骤：</p>
<figure data-type="image" tabindex="14"><img src="images%5C1563028264001.png" alt="1563028264001" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="images%5C1563028308366.png" alt="1563028308366" loading="lazy"></figure>
<p>引入pom.xml依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;
        &lt;groupId&gt;com.itheima&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;artifactId&gt;user-provider&lt;/artifactId&gt;

    &lt;!--依赖包--&gt;
    &lt;dependencies&gt;
        &lt;!--JPA包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--web起步包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--MySQL驱动包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--测试包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>(3)User对象创建</p>
<p>创建<code>com.itheima.domain.User</code>，代码如下：</p>
<pre><code class="language-java">@Entity
@Table(name = &quot;tb_user&quot;)
public class User implements Serializable{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;//主键id
    private String username;//用户名
    private String password;//密码
    private String name;//姓名
    private Integer age;//年龄
    private Integer sex;//性别 1男性，2女性
    private Date birthday; //出生日期
    private Date created; //创建时间
    private Date updated; //更新时间
    private String note;//备注
    //..set get toString 略
}
</code></pre>
<p>(4)dao<br>
创建<code>com.itheima.dao.UserDao</code>，代码如下：</p>
<pre><code class="language-java">public interface UserDao extends JpaRepository&lt;User,Integer&gt; {
}
</code></pre>
<p>(5)Service层</p>
<p>创建<code>com.itheima.service.UserService</code>接口，代码如下：</p>
<pre><code class="language-java">public interface UserService {
    /***
     * 根据ID查询用户信息
     * @param id
     * @return
     */
    User findByUserId(Integer id);
}
</code></pre>
<p>创建<code>com.itheima.service.impl.UserServiceImpl</code>代码如下：</p>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    /***
     * 根据ID查询用户信息
     * @param id
     * @return
     */
    @Override
    public User findByUserId(Integer id) {
        return userDao.findById(id).get();
    }
}
</code></pre>
<p>(6)控制层</p>
<p>创建<code>com.itheima.controller.UserController</code>，代码如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(value = &quot;/user&quot;)
public class UserController {

    @Autowired
    private UserService userService;

    /***
     * 根据ID查询用户信息
     * @param id
     * @return
     */
    @RequestMapping(value = &quot;/find/{id}&quot;)
    public User findById(@PathVariable(value = &quot;id&quot;) Integer id){
        return userService.findByUserId(id);
    }
}
</code></pre>
<p>(7)application.yml配置</p>
<pre><code class="language-properties">server:
  port: 18081
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: root
    url: jdbc:mysql://127.0.0.1:3306/springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
</code></pre>
<p>(8)启动类创建</p>
<p>创建<code>com.itheima.UserProviderApplication</code>启动类，并启动</p>
<pre><code class="language-java">@SpringBootApplication
public class UserProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserProviderApplication.class,args);
    }
}
</code></pre>
<p>测试：<code>&lt;http://localhost:18081/user/find/2&gt;</code></p>
<figure data-type="image" tabindex="16"><img src="images%5C1563028849102.png" alt="1563028849102" loading="lazy"></figure>
<h4 id="323-创建服务消费者consumer工程">3.2.3 创建服务消费者(consumer)工程</h4>
<p>在该工程中使用RestTemplate来调用user-provider微服务。</p>
<p>实现步骤：</p>
<pre><code class="language-properties">1.创建工程
2.引入依赖
3.创建Pojo
4.创建启动类，同时创建RestTemplate对象，并交给SpringIOC容器管理
5.创建application.yml文件，指定端口
6.编写Controller，在Controller中通过RestTemplate调用user-provider的服务
7.启动测试
</code></pre>
<p>(1)工程搭建</p>
<p>选中springcloud-parent工程-&gt;New Modul-&gt;Maven-&gt;输入坐标名字，如下步骤：</p>
<figure data-type="image" tabindex="17"><img src="images%5C1563028974269.png" alt="1563028974269" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="images%5C1563029007419.png" alt="1563029007419" loading="lazy"></figure>
<p>pom.xml依赖如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;
        &lt;groupId&gt;com.itheima&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;artifactId&gt;user-consumer&lt;/artifactId&gt;

    &lt;!--依赖包--&gt;
    &lt;dependencies&gt;
        &lt;!--web起步依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>(2)创建User对象</p>
<p>在src下创建<code>com.itheima.domain.User</code>,代码如下：</p>
<pre><code class="language-java">public class User implements Serializable{
    private Integer id;//主键id
    private String username;//用户名
    private String password;//密码
    private String name;//姓名
    private Integer age;//年龄
    private Integer sex;//性别 1男性，2女性
    private Date birthday; //出生日期
    private Date created; //创建时间
    private Date updated; //更新时间
    private String note;//备注
    
    //..set、get、toString 略
}
</code></pre>
<p>(3)创建启动引导类</p>
<p>在src下创建<code>com.itheima.UserConsumerApplication</code>,代码如下：</p>
<pre><code class="language-java">@SpringBootApplication
public class UserConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserConsumerApplication.class,args);
    }

    /***
     * 将RestTemplate的实例放到Spring容器中
     * @return
     */
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
</code></pre>
<p>创建application.yml,并配置端口为18082</p>
<pre><code class="language-properties">server:
  port: 18082
</code></pre>
<p>(4)创建控制层，在控制层中调用user-provider</p>
<p>在src下创建<code>com.itheima.controller.UserController</code>，代码如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(value = &quot;/consumer&quot;)
public class UserController {
    @Autowired
    private RestTemplate restTemplate;

    /**
     * 在user-consumer服务中通过RestTemplate调用user-provider服务
     * @param id
     * @return
     */
    @GetMapping(value = &quot;/{id}&quot;)
    public User queryById(@PathVariable(value = &quot;id&quot;)Integer id){
        String url = &quot;http://localhost:18081/user/find/&quot;+id;
        return restTemplate.getForObject(url,User.class);
    }
}
</code></pre>
<p>启动测试：</p>
<p>请求地址：<code>&lt;http://localhost:18082/consumer/1&gt;</code></p>
<figure data-type="image" tabindex="19"><img src="images%5C1563029284043.png" alt="1563029284043" loading="lazy"></figure>
<h4 id="324-思考问题">3.2.4 思考问题</h4>
<p>user-provider：对外提供用户查询接口</p>
<p>user-consumer：通过RestTemplate访问接口查询用户数据</p>
<p>存在的问题：</p>
<ol>
<li>在服务消费者中，我们把url地址硬编码到代码中，不方便后期维护</li>
<li>在服务消费者中，不清楚服务提供者的状态(user-provider有可能没有,或者说宕机了)</li>
<li>服务提供者只有一个服务，即便服务提供者形成<strong>集群</strong>，服务消费者还需要自己实现<strong>负载均衡</strong></li>
<li>服务提供者如果出现故障，是否能够及时发现：</li>
</ol>
<p>其实上面说的问题，概括一下就是微服务架构必然要面临的问题</p>
<ul>
<li>服务管理：自动注册与发现、状态监管</li>
<li>服务负载均衡</li>
<li>等等</li>
</ul>
<h3 id="33-小结">3.3 小结</h3>
<ul>
<li>服务消费者使用RestTemplate调用服务提供者,使用RestTemplate调用的时候，需要先创建并注入到SpringIOC容器中</li>
<li>在服务消费者中，我们把url地址硬编码到代码中，不方便后期维护</li>
<li>在服务消费者中，不清楚服务提供者的状态(user-provider有可能没有,或者宕机了)</li>
<li>服务提供者只有一个服务，即便服务提供者形成集群，服务消费者还需要自己实现负载均衡</li>
<li>服务提供者的如果出现故障，不能及时发现。</li>
</ul>
<h2 id="4-注册中心-spring-cloud-eureka"><mark>4 注册中心 Spring Cloud Eureka</mark></h2>
<p>前面我们学过Dubbo，关于Dubbo的执行过程我们看如下图片：</p>
<figure data-type="image" tabindex="20"><img src="images%5C1555072467639.png" alt="" loading="lazy"></figure>
<p>执行过程：</p>
<pre><code class="language-properties">1.Provider:服务提供者,异步将自身信息注册到Register（注册中心）
2.Consumer：服务消费者，异步去Register中拉取服务数据
3.Register异步推送服务数据给Consumer,如果有新的服务注册了，Consumer可以直接监控到新的服务
4.Consumer同步调用Provider
5.Consumer和Provider异步将调用频率信息发给Monitor监控
</code></pre>
<h3 id="41-目标">4.1 目标</h3>
<ul>
<li>理解Eureka的原理图-服务注册与发现中心</li>
<li>能实现Eureka服务的搭建</li>
<li>能实现服务提供者向Eureka注册服务</li>
<li>能实现服务消费者向Eureka注册服务</li>
<li>能实现消费者通过Eureka访问服务提供者</li>
<li><mark>能掌握Eureka的详细配置</mark></li>
</ul>
<h3 id="42-讲解">4.2 讲解</h3>
<h4 id="421-eureka-简介">4.2.1 Eureka 简介</h4>
<p>Eureka解决了第一个问题(<mark>作用</mark>)：服务的管理，注册和发现、状态监管、动态路由。</p>
<p>Eureka负责管理记录服务提供者的信息。服务调用者(消费者)无需自己寻找服务，Eureka自动匹配服务给调用者。</p>
<p>Eureka与服务之间通过<code>心跳</code>机制进行监控；</p>
<h4 id="422-原理图">4.2.2 原理图</h4>
<p>基本架构图</p>
<figure data-type="image" tabindex="21"><img src="images%5C1563089431796.png" alt="1563089431796" loading="lazy"></figure>
<p>Eureka：就是服务注册中心(可以是一个集<strong>群</strong>)，对外暴露自己的地址</p>
<p>服务提供者：启动后向Eureka注册自己的信息(地址，提供什么服务)</p>
<p>服务消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</p>
<p>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</p>
<h4 id="423-入门案例">4.2.3 入门案例</h4>
<p>目标：搭建Eureka Server环境，创建一个eureka_server工程。</p>
<p>**步骤：**分三步</p>
<pre><code class="language-properties">1：eureka-serve搭建工程eureka-server
2：服务提供者-注册服务，user-provider工程
3：服务消费者-发现服务，user-consumer工程
</code></pre>
<h5 id="4231-搭建eureka-server工程">4.2.3.1 搭建eureka-server工程</h5>
<p>(1)工程搭建</p>
<p>选中springcloud-parent工程-&gt;New Modul-&gt;Maven-&gt;输入坐标名字，如下步骤：</p>
<figure data-type="image" tabindex="22"><img src="images%5C1563093804303.png" alt="1563093804303" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="images%5C1563093844890.png" alt="1563093844890" loading="lazy"></figure>
<p>(2)pom.xml引入依赖,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;
        &lt;groupId&gt;com.itheima&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;artifactId&gt;eureka-server&lt;/artifactId&gt;

    &lt;!--依赖包,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓--&gt;
    &lt;dependencies&gt;
        &lt;!--eureka-server依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>(3)application.yml配置,打个url提示,然后点击service-url跑到一个类指定它是map,给它赋值键和值即可↓</p>
<pre><code class="language-properties">server:
  port: 7001    #端口号
spring:
  application:
    name: eureka-server # 应用名称，会在Eureka中作为服务的id标识（serviceId）
eureka:
  client:
    register-with-eureka: false   #是否将自己注册到Eureka中
    fetch-registry: false   #是否从eureka中获取服务信息
    service-url:
      defaultZone: http://localhost:7001/eureka # EurekaServer的地址
</code></pre>
<p>(4)启动类创建</p>
<p>在src下创建<code>com.itheima.EurekaServerApplication</code>,在类上需要添加一个注解<code>@EnableEurekaServer</code>，用于开启Eureka服务,代码如下：</p>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer //开启Eureka服务
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class,args);
    }
}
</code></pre>
<p>(5)启动访问</p>
<p>启动后，访问<code>&lt;http://127.0.0.1:7001/&gt;</code>，效果如下：</p>
<figure data-type="image" tabindex="24"><img src="images%5C1563094286893.png" alt="1563094286893" loading="lazy"></figure>
<h5 id="4232-服务提供者-注册服务">4.2.3.2 服务提供者-注册服务</h5>
<p>我们的user-provider属于服务提供者，需要在user-provider工程中引入Eureka客户端依赖，然后在配置文件中指定Eureka服务地址,然后在启动类中开启Eureka服务发现功能(开启Eureka客户端功能)。</p>
<p>步骤：</p>
<pre><code class="language-properties">1.引入eureka客户端依赖包
2.在application.yml中配置Eureka服务地址
3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient 
</code></pre>
<p>(1)引入依赖</p>
<p>在user-provider的pom.xml中引入如下依赖,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓</p>
<pre><code class="language-xml">&lt;!--eureka客户端--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>(2)配置Eureka服务地址</p>
<p>修改user-provider的application.yml配置文件，添加Eureka服务地址，代码如下：</p>
<figure data-type="image" tabindex="25"><img src="images%5C1563097201829.png" alt="1563097201829" loading="lazy"></figure>
<p>上图代码如下：客户端配置抄服务器的,去掉注册和抓取配置,然后修改端口和应用名即可↓</p>
<pre><code class="language-yaml">server:
  port: 18081
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: root
    url: jdbc:mysql://127.0.0.1:3306/springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
  application:
    name: user-provider #服务的名字,不同的应用，名字不同，如果是集群，名字需要相同
#指定eureka服务地址
eureka:
  client:
    service-url:
      # EurekaServer的地址
      defaultZone: http://localhost:7001/eureka
</code></pre>
<p>(3)开启Eureka客户端发现功能</p>
<p>在user-provider的启动类<code>com.itheima.UserProviderApplication</code>上添加<code>@EnableDiscoveryClient</code>注解或者<code>@EnableEurekaClient</code>，用于开启客户端发现功能。</p>
<pre><code class="language-java">@SpringBootApplication
//@EnableDiscoveryClient//开启Eureka客户端发现功能
@EnableEurekaClient     //开启Eureka客户端发现功能，注册中心只能是Eureka
public class UserProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserProviderApplication.class,args);
    }
}
</code></pre>
<p>区别：</p>
<p><code>@EnableDiscoveryClient</code>和<code>@EnableEurekaClient</code>都用于开启客户端的发现功能，但<code>@EnableEurekaClient</code>的注册中心只能是Eureka。</p>
<p>(4)启动测试</p>
<p>启动eureka-server，再启动user-provider。</p>
<p>访问Eureka地址<code>&lt;http://127.0.0.1:7001/&gt;</code>，效果如下：</p>
<figure data-type="image" tabindex="26"><img src="images%5C1563097634851.png" alt="1563097634851" loading="lazy"></figure>
<h5 id="4233-服务消费者-注册服务中心">4.2.3.3 服务消费者-注册服务中心</h5>
<p>消费方添加Eureka服务注册和生产方配置流程一致。</p>
<p>步骤：</p>
<pre><code class="language-properties">1.引入eureka客户端依赖包
2.在application.yml中配置Eureka服务地址
3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient 
</code></pre>
<p>(1)pom.xml引入依赖</p>
<p>修改user-consumer的pom.xml引入如下依赖,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓</p>
<pre><code class="language-xml">&lt;!--eureka客户端--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>(2)application.yml中配置eureka服务地址</p>
<p>修改user-consumer工程的application.yml配置，添加eureka服务地址，配置如下：</p>
<figure data-type="image" tabindex="27"><img src="images%5C1563098000059.png" alt="1563098000059" loading="lazy"></figure>
<p>上图配置如下：客户端配置抄服务器的,去掉注册和抓取配置,然后修改端口和应用名即可↓</p>
<pre><code class="language-properties">server:
  port: 18082
spring:
  application:
    name: user-consumer   #服务名字
#指定eureka服务地址
eureka:
  client:
    service-url:
      # EurekaServer的地址
      defaultZone: http://localhost:7001/eureka
</code></pre>
<p>(3)在启动类上开启Eureka服务发现功能</p>
<p>修改user-consumer的<code>com.itheima.UserConsumerApplication</code>启动类，在类上添加<code>@EnableDiscoveryClient</code>注解，代码如下：</p>
<figure data-type="image" tabindex="28"><img src="images%5C1563098256837.png" alt="1563098256837" loading="lazy"></figure>
<p>上图代码如下：</p>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient  //开启Eureka客户端发现功能
public class UserConsumerApplication {
 	public static void main(String[] args) {
        SpringApplication.run(UserConsumerApplication.class,args);
    }
}
</code></pre>
<p>(4)测试</p>
<p>启动user-consumer，然后访问Eureka服务地址<code>&lt;http://127.0.0.1:7001/&gt;</code>效果如下：</p>
<figure data-type="image" tabindex="29"><img src="images%5C1563098399496.png" alt="1563098399496" loading="lazy"></figure>
<h5 id="4234-消费者作为客户端通过eureka服务器拿到提供者注册的数据即ip和端口等去访问服务提供者">4.2.3.4 消费者作为客户端通过Eureka服务器拿到提供者注册的数据即ip和端口等,去访问服务提供者</h5>
<p>之前消费者<code>user-consumer</code>访问服务提供者<code>user-provider</code>是通过<code>http://localhost:18081/user/find/1</code>访问的，这里是具体的路径，没有从Eureka获取访问地址，我们可以让消费者从Eureka那里获取服务提供者的访问地址，然后访问服务提供者。</p>
<p>修改user-consumer的<code>com.itheima.controller.UserController</code>，代码如下：</p>
<figure data-type="image" tabindex="30"><img src="images%5C1563098992272.png" alt="1563098992272" loading="lazy"></figure>
<p>Debug跟踪运行，访问<code>&lt;http://localhost:18082/consumer/1&gt;</code>，效果如下：</p>
<figure data-type="image" tabindex="31"><img src="assets/1603337767375.png" alt="1603337767375" loading="lazy"></figure>
<p>跟踪运行后，我们发现，这里的地址就是服务注册中的状态名字↓</p>
<figure data-type="image" tabindex="32"><img src="assets/1603337295610.png" alt="1603337295610" loading="lazy"></figure>
<p>浏览器结果如下：</p>
<figure data-type="image" tabindex="33"><img src="images%5C1563099333167.png" alt="1563099333167" loading="lazy"></figure>
<p>(2)使用IP访问配置</p>
<p>上面的请求地址是服务状态名字，其实也是当前被访问主机的名字，可以通过配置文件，将它换成IP，修改<strong>提供者</strong>的application.yml配置文件，代码如下：</p>
<figure data-type="image" tabindex="34"><img src="images%5C1563100045968.png" alt="1563100045968" loading="lazy"></figure>
<p>上图配置如下：打个ip提示即可↓</p>
<pre><code class="language-yaml">  instance:
    #指定IP地址
    ip-address: 127.0.0.1
    #访问服务的时候，推荐使用IP
    prefer-ip-address: true
</code></pre>
<p>重新启动<code>user-provider</code>，有时候消费者有缓存,所以<strong>消费者也要重启</strong>!然后通过消费者再次访问，测试效果如下：</p>
<figure data-type="image" tabindex="35"><img src="assets/1603337925303.png" alt="1603337925303" loading="lazy"></figure>
<p>通过上面的测试,说明restTemplate确实能通过应用服务名user-provider来得到服务器上的提供者的ip和端口,如果你给我加上加载平衡注解,那么我就自动做了!</p>
<h4 id="424-eureka详解">4.2.4 Eureka详解</h4>
<h5 id="4241-基础架构">4.2.4.1 基础架构</h5>
<p>Eureka架构中的三个核心角色</p>
<pre><code class="language-properties">1.服务注册中心：Eureka服务端应用，提供服务注册发现功能，eureka-server
2.服务提供者：提供服务的应用
  要求统一对外提供Rest风格的服务即可
  本例子：user-provider
3.服务消费者：从注册中心获取服务列表，知道去哪调用服务提供者，user-consumer
</code></pre>
<h5 id="4242-eureka客户端">4.2.4.2 Eureka客户端</h5>
<p><strong>服务提供者</strong>要向EurekaServer注册服务，并完成服务<strong>续约</strong>等工作</p>
<p><strong>服务注册:</strong></p>
<pre><code class="language-properties">1. 当我们开启了客户端发现注解@DiscoveryClient。同时导入了eureka-client依赖坐标
2. 同时配置Eureka服务注册中心地址在配置文件中
3. 服务在启动时，检测是否有@DiscoveryClient注解和配置信息
4. 如果有，则会向注册中心发起注册请求，携带服务元数据信息(IP、端口等)到注册中心
5. Eureka注册中心会把服务的信息保存在它的Map中(万能map)。
</code></pre>
<p><strong>服务续约：</strong></p>
<p>服务注册完成以后，<strong>服务提供者</strong>会维持一个<code>心跳</code>，保证服务处于存在状态。这个称之为服务提供者续约(renew)。</p>
<figure data-type="image" tabindex="36"><img src="images%5C1563102805802.png" alt="1563102805802" loading="lazy"></figure>
<p>上图配置如下：打个lease提示即可↓</p>
<pre><code class="language-yaml">eureka:
  client:
    service-url:
      # EurekaServer的地址
      defaultZone: http://localhost:7001/eureka
  instance:
    #指定IP地址
    ip-address: 127.0.0.1
    #访问服务的时候，推荐使用IP
    prefer-ip-address: true
    #租约到期，服务时效时间，默认值90秒
    lease-expiration-duration-in-seconds: 15
    #租约续约间隔时间，默认30秒
    lease-renewal-interval-in-seconds: 40
</code></pre>
<p>**获取服务列表：**注册抓取间隔时间配置,了解</p>
<figure data-type="image" tabindex="37"><img src="images%5C1563102910373.png" alt="1563102910373" loading="lazy"></figure>
<p>上图配置如下：打个registry或者fetch提示即可↓</p>
<pre><code class="language-yaml">registry-fetch-interval-seconds: 30
</code></pre>
<p>说明：</p>
<pre><code class="language-properties">服务消费者启动时，会检测是否获取到服务注册信息配置
如果是，则会从 EurekaServer获取服务列表只读备份，缓存到消费者本地
每隔30秒，会重新获取并更新数据
每隔30秒的时间可以通过配置registry-fetch-interval-seconds修改
</code></pre>
<h5 id="4243-失效剔除和自我保护">4.2.4.3 失效剔除和自我保护</h5>
<p><strong>服务下线：</strong></p>
<pre><code>当服务正常关闭时，会发送服务下线的REST请求给EurekaServer。
服务中心接受到请求后，将该服务置为下线状态
</code></pre>
<p><strong>失效剔除：</strong></p>
<pre><code>服务注册中心,每隔一段时间(默认60秒)将列表清单中没有续约的服务剔除。
通过eviction-interval-timer-in-ms配置可以对其进行修改，单位是毫秒
</code></pre>
<p>剔除时间配置</p>
<figure data-type="image" tabindex="38"><img src="images%5C1563103529735.png" alt="1563103529735" loading="lazy"></figure>
<p>上图代码如下：自我保护和剔除时间,打个se提示即可↓</p>
<pre><code class="language-yaml">eureka:
  client:
    register-with-eureka: false   #是否将自己注册到Eureka中
    fetch-registry: false   #是否从eureka中获取服务信息
    service-url:
      defaultZone: http://localhost:7001/eureka # EurekaServer的地址
  server:
    enable-self-preservation: false
    eviction-interval-timer-in-ms: 5000
</code></pre>
<p><strong>自我保护：</strong></p>
<p>Eureka会统计服务提供者实例,最近<strong>15分钟</strong>心跳续约的比例是否低于<strong>85%，如果低于</strong>则会触发自我保护机制。</p>
<p>服务中心页面会显示如下提示信息(很容易理解,正常情况下,你服务提供者每隔30秒续约,但是你的比例太低说明你可能遇到了其他不可控的因素,比如网络问题,那我注册中心肯定不会把你的数据剔除,开启自我保护)</p>
<figure data-type="image" tabindex="39"><img src="images%5C1558056004897.png" alt="1558056004897" loading="lazy"></figure>
<p>含义：紧急情况！Eureka可能错误地声称实例已经启动，而事实并非如此。续约低于阈值(yu)，因此实例不会为了安全而过期。</p>
<pre><code class="language-properties">1.自我保护模式下，不会剔除任何服务实例
2.自我保护模式保证了大多数服务依然可用(比如为了应对服务提供者网络突然中断的问题等)
3.通过enable-self-preservation配置可用关停自我保护，默认值是打开的
</code></pre>
<p>关闭自我保护</p>
<figure data-type="image" tabindex="40"><img src="images%5C1563103437025.png" alt="1563103437025" loading="lazy"></figure>
<p>上图配置如下,即Eureka服务器关闭自我保护机制：</p>
<pre><code class="language-yaml">server:
	enable-self-preservation: false
</code></pre>
<h3 id="43-小结">4.3 小结</h3>
<ul>
<li>
<p>理解Eureka的原理图:</p>
<pre><code class="language-properties">Eureka：就是服务注册中心(可以是一个集群)，对外暴露自己的地址
服务提供者：启动后向Eureka注册自己的信息(地址，提供什么服务)
服务消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新
心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态
</code></pre>
</li>
<li>
<p>能实现Eureka服务的搭建:引入依赖包，配置配置文件，在启动类上加<code>@EnableEurekaServer</code>。</p>
</li>
<li>
<p>能实现服务提供者向Eureka注册服务</p>
<pre><code class="language-properties">1.引入eureka客户端依赖包
2.在application.yml中配置Eureka服务地址
3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient 
</code></pre>
</li>
<li>
<p>能实现服务消费者向Eureka注册服务</p>
<pre><code class="language-properties">1.引入eureka客户端依赖包
2.在application.yml中配置Eureka服务地址
3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient 
</code></pre>
</li>
<li>
<p>能实现消费者通过Eureka访问服务提供者</p>
</li>
<li>
<p><mark>最重要的是配置小结,关于配置,一般都在服务提供者,有两个节点,client节点配置客户端信息比如url,instance实例节点配置服务相关信息,这个节点配置比较多比如ip或者lease,如下所示:↓</mark></p>
<pre><code class="language-yaml">server:
  port: 18081
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC
    username: root
    password: root
  application:
    name: user-provider
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka/
    registry-fetch-interval-seconds: 30
  instance:
    prefer-ip-address: true
#    ip-address: localhost
    ip-address: 127.0.0.1
    lease-expiration-duration-in-seconds: 9
    lease-renewal-interval-in-seconds: 30
</code></pre>
</li>
<li>
<p><mark>另外服务注册中心还多了一个server服务节点,一般用来配置关闭自我保护和剔除时间,如下:↓</mark></p>
<pre><code class="language-yaml">server:
  port: 7001    #端口号
spring:
  application:
    name: eureka-server # 应用名称，会在Eureka中作为服务的id标识（serviceId）
eureka:
  client:
    register-with-eureka: false   #是否将自己注册到Eureka中
    fetch-registry: false   #是否从eureka中获取服务信息
    service-url:
      defaultZone: http://localhost:7001/eureka
  server:
    enable-self-preservation: false
    eviction-interval-timer-in-ms: 5000 # EurekaServer的地址
</code></pre>
</li>
<li>
<p><mark>到这里有些同学就有想法了,难道消费者不用配置其他东西了嘛?那你错了,接下来的客户端负载均衡,服务降级都是消费者方面的配置!咱们拭目以待↓</mark></p>
</li>
</ul>
<h2 id="5-负载均衡-spring-cloud-ribbon"><mark>5 负载均衡 Spring Cloud Ribbon</mark></h2>
<p>Ribbon主要 解决如多个服务提供者,集群服务中，多个服务高效率访问的问题。</p>
<h3 id="51-目标">5.1 目标</h3>
<ul>
<li>理解Ribbon的负载均衡应用场景</li>
<li>能实现Ribbon的轮询、随机算法配置</li>
<li>理解源码对负载均衡的切换</li>
</ul>
<h3 id="52-讲解">5.2 讲解</h3>
<h4 id="521-ribbon-简介">5.2.1 Ribbon 简介</h4>
<p>什么是Ribbon？</p>
<p>Ribbon是Netflix发布的<strong>负载均衡器</strong>，有助于<strong>控制HTTP客户端行为</strong>。为Ribbon配置服务提供者地址列表后，Ribbon就可基于负载均衡算法，自动帮助服务消费者请求。</p>
<p>Ribbon默认提供的负载均衡算法：<mark>轮询(默认)</mark>，<mark>随机</mark>,重试法,加权。当然，我们可用自己定义负载均衡算法</p>
<h4 id="522-入门案例">5.2.2 入门案例</h4>
<h5 id="5221-多个服务集群">5.2.2.1 多个服务集群</h5>
<figure data-type="image" tabindex="41"><img src="images%5C1563110459400.png" alt="1563110459400" loading="lazy"></figure>
<p>如果想要做负载均衡，我们的服务至少2个以上,为了演示负载均衡案例，我们可以复制2个工程，分别为<code>user-provider</code>和<code>user-provider-demo1</code>，可以按照如下步骤拷贝工程：</p>
<p>①选中<code>user-provider</code>,按<code>Ctrl+C</code>，然后<code>Ctrl+V</code></p>
<figure data-type="image" tabindex="42"><img src="images%5C1563110649115.png" alt="1563110649115" loading="lazy"></figure>
<p>②名字改成<code>user-provider-demo1</code>,点击OK</p>
<figure data-type="image" tabindex="43"><img src="images%5C1563110738488.png" alt="1563110738488" loading="lazy"></figure>
<p>③将<code>user-provider-demo1</code>的<code>artifactId</code>换成<code>user-provider-demo1</code></p>
<figure data-type="image" tabindex="44"><img src="images%5C1563110842156.png" alt="1563110842156" loading="lazy"></figure>
<p>④在springcloud-parent的pom.xml中添加一个<code>&lt;module&gt;user-provider-demo1&lt;/module&gt;</code></p>
<figure data-type="image" tabindex="45"><img src="images%5C1563110990061.png" alt="1563110990061" loading="lazy"></figure>
<p>⑤将<code>user-provider-demo1</code>的application.yml中的端口改成18083</p>
<figure data-type="image" tabindex="46"><img src="images%5C1563111191901.png" alt="1563111191901" loading="lazy"></figure>
<p>为了方便测试，将2个工程对应的<code>com.itheima.controller.UserController</code>都修改一下：</p>
<p><code>user-provider</code>:</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/find/{id}&quot;)
public User findById(@PathVariable(value = &quot;id&quot;) Integer id){
    User user = userService.findByUserId(id);
    user.setUsername(user+&quot;     user-provider&quot;);
    return user;
}
</code></pre>
<p><code>user-provider-demo1</code>:</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/find/{id}&quot;)
public User findById(@PathVariable(value = &quot;id&quot;) Integer id){
    User user = userService.findByUserId(id);
    user.setUsername(user+&quot;     user-provider-demo1&quot;);
    return user;
}
</code></pre>
<p><mark>⑥启动<code>eureka-server</code>和<code>user-provider</code>、<code>user-provider-demo1</code>、<code>user-consumer</code>，启动前先注释掉<code>eureka-server</code>中的自我保护和剔除服务配置。</mark></p>
<figure data-type="image" tabindex="47"><img src="images%5C1563111434062.png" alt="1563111434062" loading="lazy"></figure>
<p>访问<code>eureka-server</code>地址<code>&lt;http://127.0.0.1:7001/&gt;</code>效果如下：</p>
<figure data-type="image" tabindex="48"><img src="images%5C1563111556883.png" alt="1563111556883" loading="lazy"></figure>
<h5 id="5222-开启负载均衡">5.2.2.2 开启负载均衡</h5>
<p>(1)客户端开启负载均衡</p>
<p>Eureka已经集成Ribbon，所以无需引入依赖,要想使用Ribbon，直接在RestTemplate的配置方法上添加<code>@LoadBalanced</code>注解即可</p>
<p>修改<code>user-consumer</code>的<code>com.itheima.UserConsumerApplication</code>启动类，<mark>在<code>restTemplate()</code>方法上添加<code>@LoadBalanced</code>注解</mark>，代码如下：</p>
<figure data-type="image" tabindex="49"><img src="images%5C1563112003073.png" alt="1563112003073" loading="lazy"></figure>
<p>(2)采用<mark>服务提供者服务名访问</mark>配置</p>
<p>修改<code>user-consumer</code>的<code>com.itheima.controller.UserController</code>的调用方式，不再手动获取ip和端口，而是直接通过服务名称调用，代码如下：</p>
<figure data-type="image" tabindex="50"><img src="images%5C1563112311866.png" alt="1563112311866" loading="lazy"></figure>
<p>(3)测试</p>
<p>启动并访问测试<code>&lt;http://localhost:18082/consumer/1&gt;</code>,可以发现，数据会在2个服务之间轮询切换。</p>
<figure data-type="image" tabindex="51"><img src="images%5C1563113049010.png" alt="1563113049010" loading="lazy"></figure>
<h5 id="5223-其他负载均衡策略配置把下面配置拷贝到消费者的配置文件即可"><mark>5.2.2.3 其他负载均衡策略配置,把下面配置拷贝到消费者的配置文件即可↓</mark></h5>
<p>配置修改轮询策略：Ribbon默认的负载均衡策略是轮询，通过如下配置可做修改,联系记忆bb,cckey,随机规则↓</p>
<pre><code class="language-yaml"># 修改服务地址轮询策略，默认是轮询，配置之后变随机↑
user-provider: #不能省要告诉我对哪个服务提供者进行负载均衡,NFLoadBalancerRuleClassName忘了搜ccckey里面找带有负载均衡规则类名,接下来赋值类,基本上你会写随机规则类或者轮询规则,但是不写配置就是轮询
  ribbon:
    #轮询
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
    #随机算法
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
    #重试算法,该算法先按照轮询的策略获取服务,如果获取服务失败则在指定的时间内会进行重试，获取可用的服务↓
    #可以在idea软件中按ctr shift n或者t搜对应的类进行其中一种算法涉及时间的说明↑
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule
    #加权法,会根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越大。刚启动时如果统计信息不足，则使用轮询的策略，等统计信息足够,才会切换到自身规则。
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.ZoneAvoidanceRule
</code></pre>
<p>SpringBoot可以修改负载均衡规则，配置为<code>ribbon.NFLoadBalancerRuleClassName</code></p>
<p>格式{服务名称}.ribbon.NFLoadBalancerRuleClassName</p>
<h4 id="523-负载均衡源码跟踪探究">5.2.3 负载均衡源码跟踪探究</h4>
<p><mark>为什么只输入了Service服务名称比如user-provider就可以访问了呢？不应该需要获取ip和端口吗？</mark></p>
<p>负载均衡器动态的从Eureka服务注册中心,获取服务提供者的访问地址(host、port)</p>
<p>显然是有某个<strong>组件</strong>根据Service服务名称，获取了服务实例ip和端口。就是<strong>组件</strong>就是<mark>LoadBalancerInterceptor</mark></p>
<p><mark>这个拦截器类会对RestTemplate的请求进行拦截，然后从Eureka根据<strong>服务id如user-provider</strong>获取服务列表，随后利用负载均衡算法得到<strong>真正服务地址</strong>信息，替换服务id如user-provider。</mark></p>
<p>源码跟踪步骤：</p>
<p>打开LoadBalancerInterceptor类(搜类用ctr shift n或者ctr shift t)，断点打入intercept方法中</p>
<figure data-type="image" tabindex="52"><img src="images%5C1563118138994.png" alt="1563118138994" loading="lazy"></figure>
<p>经过测试知道等会会来到Ribbon负载均衡客户端RibbonLoadBalancerClient类的execute方法：发现获取了18081发端口的服务(<mark>重点关注这里即可,在server处加断点,看到ip后点绿色正方体按钮<img src="assets/1603348184530.png" alt="1603348184530" loading="lazy">放行,进行下一次的测试↓</mark>)</p>
<figure data-type="image" tabindex="53"><img src="images%5C1563118256259.png" alt="1563118256259" loading="lazy"></figure>
<p>再跟下一次，发现获取的是18081和18083之间切换</p>
<figure data-type="image" tabindex="54"><img src="images%5C1563118382026.png" alt="1563118382026" loading="lazy"></figure>
<p>通过代码断点源码调试,证明了我们的前面的结论的正确</p>
<h3 id="53-小结">5.3 小结</h3>
<ul>
<li>Ribbon的<strong>负载均衡算法应用在客户端(Http请求)</strong>，只需要提供服务列表，就能帮助消费端自动访问服务端，并通过不同算法来实现客户端消费者的负载均衡。</li>
<li>Ribbon的轮询、随机算法配置：在application.yml中配置 <code>{服务名称}.ribbon.NFLoadBalancerRuleClassName</code></li>
<li>负载均衡的切换:LoadBalancerInterceptor负载均衡类获取服务的名字，通过调用RibbonLoadBalancerClient负载均衡客户端类的execute执行方法，并获取ILoadBalancer到负载均衡器，然后根据ILoadBalancer负载均衡器,查询出要使用的节点，再获取节点的信息，实现调用。</li>
</ul>
<h2 id="6-熔断器-spring-cloud-hystrix"><mark>6 熔断器 Spring Cloud Hystrix</mark></h2>
<h3 id="61-目标">6.1 目标</h3>
<ul>
<li>理解Hystrix的作用</li>
<li>理解雪崩效应</li>
<li>知道熔断器的3个状态以及3个状态的切换过程</li>
<li>能理解什么是线程隔离，什么是服务降级</li>
<li>能实现一个局部方法熔断案例</li>
<li>能实现全局方法熔断案例</li>
</ul>
<h3 id="62-讲解">6.2 讲解</h3>
<h4 id="621-hystrix-简介">6.2.1 Hystrix 简介</h4>
<figure data-type="image" tabindex="55"><img src="images%5Chystrix-logo-tagline-640.png" alt="hystrix-logo-tagline-640" loading="lazy"></figure>
<p>Hystrix，英文意思是豪猪，全身是刺，刺是一种保护机制。Hystrix也是Netflix公司的一款组件。</p>
<p><mark>Hystrix的作用是什么？：实现服务熔断降级处理，保护微服务，防止雪崩效应发生。</mark></p>
<p>Hystrix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库、防止出现<strong>级联失败</strong>也就是<strong>雪崩效应</strong>的情况发生.</p>
<h4 id="622-雪崩效应">6.2.2 雪崩效应</h4>
<p>什么是雪崩效应？</p>
<pre><code class="language-properties">1.微服务中，一个请求可能需要多个微服务接口才能实现，会形成复杂的调用链路。
2.如果某服务出现异常，请求阻塞，用户得不到响应，容器中线程不会释放，于是越来越多用户请求堆积，越来越多线程阻塞。
3.单台服务器支持线程和并发数有限，请求如果一直阻塞，会导致服务器资源耗尽，从而导致所有其他服务都不可用，从而形成雪崩效应；
</code></pre>
<p>Hystrix解决雪崩问题的手段，主要是线程隔离,服务降级**(兜底)**；</p>
<h4 id="623-熔断原理分析">6.2.3 熔断原理分析</h4>
<figure data-type="image" tabindex="56"><img src="images%5C1558425403175.png" alt="1558425403175" loading="lazy"></figure>
<p>熔断器的原理很简单，如同电力过载保护器。</p>
<p>熔断器状态机有3个状态：</p>
<pre><code class="language-properties">1.Closed：关闭状态，所有请求正常访问
2.Open：打开状态，所有请求都会被降级。
  Hystrix会对请求情况计数，当一定时间失败请求百分比达到阈(yu：四声)值(极限值)，则触发熔断，断路器完全关闭
  默认失败比例的阈值是50%，请求次数最低不少于20次
3.Half Open：半开状态
  Open状态不是永久的，打开一会后会进入休眠时间(默认5秒)。休眠时间过后会进入半开状态。
  半开状态：熔断器会判断下一次请求的返回状况，如果成功，熔断器切回closed状态。如果失败，熔断器切回open状态。
threshold reached 到达阈(yu：四声)值
under threshold  阈值以下
</code></pre>
<figure data-type="image" tabindex="57"><img src="images%5C1558064571689.png" alt="1558064571689" loading="lazy"></figure>
<p>​																		【Hystrix熔断状态机模型：配图】</p>
<p><strong>翻译之后的图：</strong></p>
<figure data-type="image" tabindex="58"><img src="images%5C1563120878233.png" alt="1563120878233" loading="lazy"></figure>
<p><strong>熔断器的核心：线程隔离和服务降级。</strong></p>
<pre><code class="language-properties">1.线程隔离：是指Hystrix为每个依赖服务调用一个小的线程池，如果线程池用尽，调用立即被拒绝，默认不采用排队。
2.服务降级(兜底方法)：优先保证核心服务，而非核心服务不可用或弱可用。触发Hystrix服务降级的情况：线程池已满、请求超时等。
</code></pre>
<p>线程隔离和服务降级之后，用户请求故障时，线程不会被阻塞，更不会无休止等待或者看到系统奔溃，至少可以看到执行结果(熔断机制)。</p>
<h4 id="624-局部熔断服务降级案例">6.2.4 局部熔断/服务降级案例</h4>
<p>目标：服务提供者的服务出现了故障，服务消费者快速失败给用户友好提示。体验服务降级</p>
<p>降级：某个方法发生故障，则返回默认的数据给用户，此时叫服务降级。</p>
<p><strong>实现步骤：</strong></p>
<p>(1)消费者,引入熔断的依赖坐标：</p>
<p>在<code>user-consumer</code>中加入依赖</p>
<pre><code class="language-xml">&lt;!--熔断器--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><mark>(2)开启熔断的注解</mark></p>
<p>修改<code>user-consumer</code>的<code>com.itheima.UserConsumerApplication</code>,在该类上添加<code>@EnableCircuitBreaker</code>,代码如下：</p>
<figure data-type="image" tabindex="59"><img src="images%5C1563121853130.png" alt="1563121853130" loading="lazy"></figure>
<p><mark>注意：这里也可以使用<code>@SpringCloudApplication</code>,写了<code>@SpringCloudApplication</code>后，其他注解需要全部去掉。</mark></p>
<pre><code>@SpringCloudApplication//一个顶上面三个,打开这个注解看到里面就有上面三个注解↓
</code></pre>
<figure data-type="image" tabindex="60"><img src="assets/1601927477681.png" alt="1601927477681" loading="lazy"></figure>
<p>(3)服务降级处理,说白了就是搞一个替补方法不走原来应该走的方法,因为原来方法出现了问题↓</p>
<p>在<code>user-consumer</code>的<code>com.itheima.controller.UserController</code>中添加降级处理方法，方法如下：</p>
<pre><code class="language-java">/**
 * 服务降级处理方法
 * @return
 */
public User failBack(Integer id){
    User user = new User();
    user.setUsername(&quot;服务降级,默认处理！&quot;);
    return  user;
}
</code></pre>
<p>在有可能发生问题的方法上添加降级处理调用，例如在<code>queryById</code>方法上添加降级调用，代码如下：</p>
<figure data-type="image" tabindex="61"><img src="images%5C1563122266205.png" alt="1563122266205" loading="lazy"></figure>
<p>(4)测试</p>
<p>将服务全部停掉，启动<code>eureka-server</code>和<code>user-consumer</code>,然后请求<code>&lt;http://localhost:18082/consumer/1&gt;</code>测试效果如下：</p>
<figure data-type="image" tabindex="62"><img src="images%5C1563122351298.png" alt="1563122351298" loading="lazy"></figure>
<h4 id="625-扩展-服务降级的fallback方法">6.2.5 扩展-服务降级的fallback方法：</h4>
<!--注意：因为熔断的降级逻辑方法跟正常逻辑方法一样，必须保证相同的参数列表和返回值相同-->
<p>两种编写方式：编写在类上，编写在方法上。</p>
<p>在类的上边对类的所有方法都生效。在方法上，仅对当前方法有效。</p>
<p>(1)方法上服务降级的fallback兜底方法</p>
<pre><code class="language-properties">使用HystrixCommon注解，定义
@HystrixCommand(fallbackMethod=&quot;failBack&quot;)用来声明一个降级逻辑的fallback兜底方法
</code></pre>
<p>(2)类上默认服务降级的fallback兜底方法</p>
<pre><code class="language-properties">刚才把fallback写在了某个业务方法上，如果方法很多，可以将FallBack配置加在类上，实现默认FallBack
@DefaultProperties(defaultFallback=”defaultFailBack“)，在类上，指明统一的失败降级方法；
</code></pre>
<p>(3)案例</p>
<p>a.在<code>user-consumer</code>的<code>com.itheima.controller.UserController</code>类中添加一个全局熔断方法：</p>
<pre><code class="language-java">/**
 * 全局的服务降级处理方法
 * @return
 */
public User defaultFailBack(){
    User user = new User();
    user.setUsername(&quot;Default-服务降级,默认处理！&quot;);
    return  user;
}
</code></pre>
<p>b.在<code>queryById</code>方法上将原来的<code>@HystrixCommand</code>相关去掉，并添加<code>@HystrixCommand</code>注解：</p>
<pre><code class="language-java">@HystrixCommand
@GetMapping(value = &quot;/{id}&quot;)
public User queryById(@PathVariable(value = &quot;id&quot;)Integer id){
    //...略
    return  user;
}
</code></pre>
<p>c.在<code>user-consumer</code>的<code>com.itheima.controller.UserController</code>类上添加<code>@DefaultProperties(defaultFallback = &quot;defaultFailBack&quot;)</code></p>
<p>d.测试访问<code>&lt;http://localhost:18082/consumer/1&gt;</code>，效果如下：</p>
<figure data-type="image" tabindex="63"><img src="images%5C1563127220002.png" alt="1563127220002" loading="lazy"></figure>
<p><code>com.itheima.controller.UserController</code>完整代码：</p>
<figure data-type="image" tabindex="64"><img src="images%5C1563127319873.png" alt="1563127319873" loading="lazy"></figure>
<p><strong><mark>熔断器熔断流程和3个状态讲解,理解为类似饭堂保安↓</mark></strong></p>
<figure data-type="image" tabindex="65"><img src="assets/1601957022241.png" alt="1601957022241" loading="lazy"></figure>
<h4 id="熔断器服务降级局部方法降级全局方法降级看这个总结即可简单另外再看看熔断策略配置的一些参数即可"><mark>熔断器服务降级,局部方法降级,全局方法降级看这个总结即可,简单,另外再看看熔断策略配置的一些参数即可↓</mark></h4>
<p><mark>@DefaultProperties可以不用,其实没那么复杂,用一个注解@HystrixCommand里面的两个属性来分别指定即可↓</mark></p>
<figure data-type="image" tabindex="66"><img src="assets/1601929327118.png" alt="1601929327118" loading="lazy"></figure>
<p>当然,别忘了引入hystrix熔断器依赖和用@SpringCloudApplication注解开启熔断器↓</p>
<figure data-type="image" tabindex="67"><img src="assets/1601929668683.png" alt="1601929668683" loading="lazy"></figure>
<h4 id="626-其他熔断策略配置放最后讲如果你不想配置那就保持默认值">6.2.6 其他熔断策略配置,放最后讲,如果你不想配置,那就保持默认值↓</h4>
<h4 id="熔断器命令默认配置策略配置记不住按shift键两次搜索打开hystrixcommandproperties类查看一下就知道"><mark>熔断器命令默认配置策略配置记不住?,按shift键两次搜索打开HystrixCommandProperties类查看一下就知道↓</mark></h4>
<figure data-type="image" tabindex="68"><img src="assets/1601956740950.png" alt="1601956740950" loading="lazy"></figure>
<p>消费者,搜索hystrix命令属性类,查看对应的配置熔断策略,拷贝下来修修改改即可↑↓</p>
<figure data-type="image" tabindex="69"><img src="assets/1603358255013.png" alt="1603358255013" loading="lazy"></figure>
<pre><code class="language-yaml"># 消费者,搜索hystrix命令属性类,查看对应的配置熔断策略,拷贝下来修修改改即可,注意首字母小写↓：
hystrix:
  command:
    default:
      circuitBreaker:
        # 强制打开熔断器 默认false关闭的。测试配置是否生效
        forceOpen: false
        # 触发熔断错误比例阈值，默认值50%!!!
        errorThresholdPercentage: 50
        # 熔断后休眠时长，默认值5秒,即睡眠5秒去看服务如果没有问题,熔断器由半开到关闭,恢复服务的访问
        sleepWindowInMilliseconds: 10000
        # 熔断触发最小请求次数，默认值是20,即请求访问服务,服务出现错误2次开始触发熔断全开
        requestVolumeThreshold: 2
      execution:
        isolation:
          thread:
            # 熔断降级超时设置，默认为1秒,即访问服务耗时超过1秒就服务降级
            timeoutInMilliseconds: 2000
</code></pre>
<h4 id="如果是properties文件前面都是hystrixcommanddefault后面忘了抄下面即可所以了忘了就对了"><mark>如果是properties文件,前面都是hystrix.command.default.,后面忘了抄下面即可,所以了忘了就对了↓</mark></h4>
<figure data-type="image" tabindex="70"><img src="assets/1601958115329.png" alt="1601958115329" loading="lazy"></figure>
<figure data-type="image" tabindex="71"><img src="assets/1601958436908.png" alt="1601958436908" loading="lazy"></figure>
<h4 id="测试第一个forceopen和最后两个requestvolumethresholdtimeoutinmilliseconds其他全部搞定"><mark>测试第一个forceOpen和最后两个requestVolumeThreshold,timeoutInMilliseconds,其他全部搞定↑</mark></h4>
<p>(1)超时时间测试</p>
<p>a.修改<code>user-provider</code>的<code>com.itheima.controller.UserController</code>的<code>findById</code>方法，让它休眠3秒钟。</p>
<p>b.修改<code>user-consumer</code>的application.yml，设置超时时间5秒，此时不会熔断。</p>
<figure data-type="image" tabindex="72"><img src="../../../../../45%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%A4%8D%E5%88%B6%E5%88%B0%E4%BD%A0%E7%94%B5%E8%84%91%E4%B8%8D%E8%A6%81%E5%89%AA%E5%88%87!!!/%E8%BF%9B%E9%98%B6%E9%98%B6%E6%AE%B5/%E5%9B%BD%E5%BA%86%E7%A6%8F%E5%88%A9/%E7%AC%AC51%E7%AB%A0%EF%BC%88springcloud_resttemplate_eureka_ribbon_hystrix%EF%BC%89/%E7%AC%94%E8%AE%B0/images/1563125744650.png" alt="1563125744650" loading="lazy"></figure>
<p>c.如果把超时时间改成2000，此时就会熔断。</p>
<p>(2)熔断触发最小请求次数测试</p>
<p>a.修改<code>user-provider</code>的<code>com.itheima.controller.UserController</code>,在方法中制造异常，代码如下：</p>
<figure data-type="image" tabindex="73"><img src="../../../../../45%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%A4%8D%E5%88%B6%E5%88%B0%E4%BD%A0%E7%94%B5%E8%84%91%E4%B8%8D%E8%A6%81%E5%89%AA%E5%88%87!!!/%E8%BF%9B%E9%98%B6%E9%98%B6%E6%AE%B5/%E5%9B%BD%E5%BA%86%E7%A6%8F%E5%88%A9/%E7%AC%AC51%E7%AB%A0%EF%BC%88springcloud_resttemplate_eureka_ribbon_hystrix%EF%BC%89/%E7%AC%94%E8%AE%B0/images/1563126432239.png" alt="1563126432239" loading="lazy"></figure>
<p>b.3次并发请求<code>&lt;http://localhost:18082/consumer/1&gt;</code>，会触发熔断</p>
<p>再次请求<code>&lt;http://localhost:18082/consumer/2&gt;</code>的时候，也会熔断，5秒钟会自动恢复。</p>
<p>并发请求建议使用<code>jmeter</code>工具。</p>
<h3 id="63-小结">6.3 小结</h3>
<ul>
<li>
<p>Hystrix的作用:用于隔离访问远程服务、第三方库、防止出现级联失败也就是雪崩效应。</p>
</li>
<li>
<p>理解雪崩效应:</p>
<pre><code class="language-properties">1.微服务中，一个请求可能需要多个微服务接口才能实现，会形成复杂的调用链路。
2.如果某服务出现异常，请求阻塞，用户得不到响应，容器中线程不会释放，于是越来越多用户请求堆积，越来越多线程阻塞。
3.单服务器支持线程和并发数有限，请求如果一直阻塞，会导致服务器资源耗尽，从而导致所有其他服务都不可用，从而形成雪崩效应；
</code></pre>
</li>
<li>
<p>知道熔断器的3个状态以及3个状态的切换过程</p>
<pre><code class="language-properties">1.Closed：关闭状态，所有请求正常访问
2.Open：打开状态，所有请求都会被降级。
  Hystrix会对请求情况计数，当一定时间失败请求百分比达到阈(yu：四声)值(极限值)，则触发熔断，断路器完全关闭
  默认失败比例的阈值是50%，请求次数最低不少于20次
3.Half Open：半开状态
  Open状态不是永久的，打开一会后会进入休眠时间(默认5秒)。休眠时间过后会进入半开状态。
  半开状态：熔断器会判断下一次请求的返回状况，如果成功，熔断器切回closed状态。如果失败，熔断器切回open状态。
threshold reached 到达阈(yu：四声)值
under threshold  阈值以下
</code></pre>
</li>
<li>
<p>能理解什么是线程隔离，什么是服务降级</p>
<pre><code class="language-properties">1.线程隔离：是指Hystrix为每个依赖服务调用一个小的线程池，如果线程池用尽，调用立即被拒绝，默认不采用排队。
2.服务降级(兜底方法)：优先保证核心服务，而非核心服务不可用或弱可用。触发Hystrix服务降级的情况：线程池已满、请求超时。
</code></pre>
</li>
<li>
<p>能实现一个局部方法熔断案例</p>
<pre><code class="language-properties">1.定义一个局部处理熔断的方法failBack()
2.在指定方法上使用@HystrixCommand(fallbackMethod = &quot;failBack&quot;)配置调用
</code></pre>
</li>
<li>
<p>能实现全局方法熔断案例</p>
<pre><code class="language-properties">1.定义一个全局处理熔断的方法defaultFailBack()
2.在类上使用@DefaultProperties(defaultFallback = &quot;defaultFailBack&quot;)配置调用
3.在指定方法上使用@HystrixCommand
</code></pre>
</li>
</ul>
]]></summary>
        <content type="html"><![CDATA[<h1 id="第1天-springcloud">第1天 SpringCloud</h1>
<h2 id="学习目标">学习目标</h2>
<ul>
<li>
<p>能够理解SpringCloud作用</p>
<ul>
<li>用来做微服务架构的技术解决方案</li>
<li><mark>SpringCloud基于SpringBoot开发的，SpringCloud整合了很多优秀的第三方微服务开源框架</mark></li>
</ul>
</li>
<li>
<p>能够使用RestTemplate发送请求</p>
<ul>
<li>封装了基于Rest的Http请求[实现Http请求]</li>
<li>可以实现Java对象序列化与反序列化[序列化与反序列化]</li>
</ul>
</li>
<li>
<p><mark>能够搭建Eureka注册中心</mark></p>
<ul>
<li>用于管理服务、监控服务、服务路由</li>
</ul>
</li>
<li>
<p>项目注册:服务提供者注册、服务消费者注册、Eureka注册中心(Zookeeper)</p>
</li>
<li>
<p>能够使用<mark>Ribbon负载均衡</mark></p>
<ul>
<li>用来实现负载均衡(实现消费方负载均衡)</li>
</ul>
</li>
<li>
<p>能够使用<mark>Hystrix</mark>熔断器</p>
<ul>
<li>做服务降级，防止程序发生雪崩</li>
</ul>
</li>
</ul>
<h2 id="1-初识spring-cloud">1 初识Spring Cloud</h2>
<p>大家谈起的微服务，大多来讲说的只不过是种架构方式。其实现方式很多种：Spring Cloud，Dubbo，华为的Service Combo，Istio 。</p>
<p>那么这么多的微服务架构产品中，我们为什么要用Spring Cloud？因为它后台硬、技术强、群众基础好，使用方便；</p>
<h3 id="11-目标">1.1 目标</h3>
<ul>
<li>了解微服务架构</li>
<li>了解SpringCloud技术</li>
</ul>
<h3 id="12-讲解">1.2 讲解</h3>
<h4 id="121-技术架构演变">1.2.1 技术架构演变</h4>
<p>(1)单一应用架构</p>
<p>当网站流量很小时，只需要一个应用，所有功能部署在一起，减少部署节点成本的框架称之为集中式框架。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。</p>
<figure data-type="image" tabindex="1"><img src="images%5C1563128795202.png" alt="1563128795202" loading="lazy"></figure>
<p>(2)垂直应用架构</p>
<p>当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。</p>
<figure data-type="image" tabindex="2"><img src="images%5C1563128890388.png" alt="1563128890388" loading="lazy"></figure>
<p>(3)分布式服务架构</p>
<p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。</p>
<figure data-type="image" tabindex="3"><img src="images%5C1563129132684.png" alt="1563129132684" loading="lazy"></figure>
<p>(4)面向服务(SOA)架构</p>
<p>典型代表有两个：流动计算架构和微服务架构；</p>
<p><strong>流动计算架构：</strong></p>
<p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。流动计算架构的最佳实践阿里的Dubbo。</p>
<p><strong>微服务架构</strong></p>
<p>与流动计算架构很相似，除了具备流动计算架构优势外，微服务架构中的微服务可以独立部署，独立发展。且微服务的开发不会限制于任何技术栈。微服务架构的最佳实践是SpringCloud。</p>
<figure data-type="image" tabindex="4"><img src="images%5C1563128667644.png" alt="1563128667644" loading="lazy"></figure>
<h4 id="122-springcloud简介">1.2.2 SpringCloud简介</h4>
<p>(1)SpringCloud介绍</p>
<p>Spring Boot擅长的是集成，把世界上最好的框架集成到自己项目中</p>
<p><mark>Spring Cloud本身也是基于SpringBoot开发而来，SpringCloud是一系列框架的有序集合,也是把非常流行的微服务的技术整合到一起，是属于微服务架构的一站式技术解决方案。</mark></p>
<p>Spring Cloud包含了：</p>
<p>注册中心：<mark>Eureka、consul</mark>、Zookeeper</p>
<p>负载均衡：Ribbon</p>
<p>熔断器：Hystrix</p>
<p>服务通信：Feign</p>
<p>网关：Gateway</p>
<p>配置中心 ：config</p>
<p>消息总线：Bus</p>
<p>集群状态等等....功能。</p>
<p>Spring Cloud协调分布式环境中各个微服务，为各类服务提供支持。</p>
<figure data-type="image" tabindex="5"><img src="images%5C1555072329184.png" alt="" loading="lazy"></figure>
<p>(2)Spring Cloud的版本</p>
<figure data-type="image" tabindex="6"><img src="images%5C1563019084631.png" alt="1563019084631" loading="lazy"></figure>
<p>版本说明：</p>
<pre><code class="language-properties">SpringCloud是一系列框架组合，为了避免与框架版本产生混淆，采用新的版本命名方式，形式为大版本名+子版本名称
  大版本名用伦敦地铁站名
  子版本名称三种
    SNAPSHOT：快照版本，尝鲜版，随时可能修改
    M版本，MileStone，M1表示第一个里程碑版本，一般同时标注PRE，表示预览版
    SR，Service Release，SR1表示第一个正式版本，同时标注GA(Generally Available)，稳定版
</code></pre>
<p>(3)SpringCloud与SpringBoot版本匹配关系</p>
<table>
<thead>
<tr>
<th>SpringBoot</th>
<th>SpringCloud</th>
</tr>
</thead>
<tbody>
<tr>
<td>1.2.x</td>
<td>Angel版本</td>
</tr>
<tr>
<td>1.3.x</td>
<td>Brixton版本</td>
</tr>
<tr>
<td>1.4.x</td>
<td>Camden版本</td>
</tr>
<tr>
<td>1.5.x</td>
<td>Dalston版本、Edgware</td>
</tr>
<tr>
<td>2.0.x</td>
<td>Finchley版本</td>
</tr>
<tr>
<td>2.1.x</td>
<td>Greenwich GA版本 (2019年2月发布)</td>
</tr>
</tbody>
</table>
<p>鉴于SpringBoot与SpringCloud关系，SpringBoot建议采用2.1.x版本</p>
<h3 id="13-小结">1.3 小结</h3>
<ul>
<li>微服务架构：就是将相关的功能独立出来，单独创建一个项目，并且连数据库也独立出来，单独创建对应的数据库。本质：将相关独立的业务完全独立出来，对应的工程和数据库也完全独立出来。</li>
<li>Spring Cloud本身也是基于SpringBoot开发而来，SpringCloud是一系列框架的有序集合,把非常流行的微服务的技术整合到了一起。</li>
</ul>
<h2 id="2-服务调用方式">2 服务调用方式</h2>
<h3 id="21-目标">2.1 目标</h3>
<ul>
<li>理解RPC和HTTP的区别</li>
<li>能使用RestTemplate发送请求(发送Http请求)</li>
</ul>
<h3 id="22-讲解">2.2 讲解</h3>
<h4 id="221-rpc和http">2.2.1 RPC和HTTP</h4>
<p>常见远程调用方式：</p>
<p>RPC:(Remote Produce Call)远程过程调用</p>
<pre><code class="language-properties">1.基于Socket
2.自定义数据格式
3.速度快，效率高
4.典型应用代表：Dubbo，WebService，ElasticSearch集群间互相调用
</code></pre>
<p>HTTP：网络传输协议</p>
<pre><code class="language-properties">1.基于TCP/IP
2.规定数据传输格式
3.缺点是消息封装比较臃肿、传输速度比较慢
4.优点是对服务提供和调用方式没有任何技术限定，自由灵活，更符合微服务理念
</code></pre>
<p>RPC和HTTP的区别：RPC是根据语言API来定义，而不是根据基于网络的应用来定义。</p>
<p>Http客户端工具</p>
<p>常见Http客户端工具：HttpClient(发送Http请求)、OKHttp(发送Http请求)、URLConnection(发送Http请求)。</p>
<h4 id="222-spring的resttemplate">2.2.2 Spring的RestTemplate</h4>
<p>(1)RestTemplate介绍</p>
<ul>
<li>RestTemplate是Rest的HTTP客户端模板工具类</li>
<li>对基于Http的客户端进行封装</li>
<li>实现对象与JSON的序列化与反序列化(JSON&lt;-&gt;JavaBean)</li>
<li>不限定客户端类型，目前常用的3种客户端都支持：HttpClient、OKHttp、JDK原生URLConnection(默认方式)</li>
</ul>
<p>(2)RestTemplate入门案例</p>
<figure data-type="image" tabindex="7"><img src="images%5C1563020200215.png" alt="1563020200215" loading="lazy"></figure>
<p>我们可以使用RestTemplate实现上图中的请求，<code>springcloud-day1-resttemplate</code>通过发送请求，请求<code>springcloud-day1-provider</code>的<code>/user/list</code>方法。</p>
<p>(1)搭建<code>springcloud-day1-provider</code></p>
<p>这里不演示详细过程了，大家直接使用IDEA搭建一个普通的SpringBoot工程即可。</p>
<p>坐标</p>
<pre><code class="language-xml">&lt;groupId&gt;com.itheima&lt;/groupId&gt;
&lt;artifactId&gt;springcloud-day1-provider&lt;/artifactId&gt;
&lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt;
</code></pre>
<p>pom.xml依赖</p>
<pre><code class="language-xml">&lt;!--父工程--&gt;
&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
	&lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
	&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
	&lt;!--web起步依赖--&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>创建<code>com.itheima.domain.User</code></p>
<pre><code class="language-java">public class User implements Serializable {
    private String name;
    private String address;
    private Integer age;

    public User() {
    }

    public User(String name, String address, Integer age) {
        this.name = name;
        this.address = address;
        this.age = age;
    }
    //..get set toString 略
}
</code></pre>
<p>application.properties</p>
<pre><code class="language-properties">server.port=18081
</code></pre>
<p>创建<code>com.itheima.controller.UserController</code>,代码如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(value = &quot;/user&quot;)
public class UserController {

    /***
     * 提供服务
     * @return
     */
    @RequestMapping(value = &quot;/list&quot;)
    public List&lt;User&gt; list(){
        List&lt;User&gt; users = new ArrayList&lt;User&gt;();
        users.add(new User(&quot;王五&quot;, &quot;深圳&quot;, 25));
        users.add(new User(&quot;李四&quot;, &quot;北京&quot;, 23));
        users.add(new User(&quot;赵六&quot;, &quot;上海&quot;, 26));
        return users;
    }
}
</code></pre>
<p>创建启动类，并启动工程</p>
<pre><code class="language-java">@SpringBootApplication
public class SpringcloudDay1ProviderApplication {
	public static void main(String[] args) {
		SpringApplication.run(SpringcloudDay1ProviderApplication.class, args);
	}
}
</code></pre>
<p>访问：<code>&lt;http://localhost:18081/user/list&gt;</code>效果如下：</p>
<figure data-type="image" tabindex="8"><img src="images%5C1563020871025.png" alt="1563020871025" loading="lazy"></figure>
<p>(2)创建<code>springcloud-day1-resttemplate</code></p>
<p>创建的详细过程也不讲解了，直接使用IDEA创建一个SpringBoot工程即可。</p>
<p>pom.xml依赖</p>
<pre><code class="language-xml">&lt;!--父工程--&gt;
&lt;parent&gt;
	&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
	&lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
	&lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
	&lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt;
&lt;/parent&gt;

&lt;dependencies&gt;
	&lt;!--web起步依赖--&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
	&lt;/dependency&gt;

	&lt;!--测试包--&gt;
	&lt;dependency&gt;
		&lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
		&lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
		&lt;scope&gt;test&lt;/scope&gt;
	&lt;/dependency&gt;
&lt;/dependencies&gt;
</code></pre>
<p>创建启动类，并在启动类中创建RestTemplate对象</p>
<pre><code class="language-java">@SpringBootApplication
public class SpringcloudDay1ResttemplateApplication {

	public static void main(String[] args) {
		SpringApplication.run(SpringcloudDay1ResttemplateApplication.class, args);
	}

	/***
	 * @Bean:创建一个对象实例，并将对象交给Spring容器管理
	 * &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot; /&gt;
	 * @return
	 */
	@Bean
	public RestTemplate restTemplate(){
		return  new RestTemplate();
	}
}
</code></pre>
<p>测试</p>
<p>在测试类HttpDemoApplicationTests中<code>@Autowired</code>注入RestTemplate</p>
<p>通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码</p>
<p>RestTemplate会自动发起请求，接收响应</p>
<p>并且帮我们对响应结果进行反序列化</p>
<p>代码如下：</p>
<pre><code class="language-java">@RunWith(SpringRunner.class)
@SpringBootTest
public class SpringcloudDay1ResttemplateApplicationTests {
	@Autowired
	private RestTemplate restTemplate;

	/**
	 * RestTemplate远程调用
	 */
	@Test
	public void testRestTemplateQuery() {
		String url = &quot;http://localhost:18081/user/list&quot;;
		String result = restTemplate.getForObject(url, String.class);
		System.out.println(result);
	}
}
</code></pre>
<p>运行测试方法，效果如下：</p>
<figure data-type="image" tabindex="9"><img src="images%5C1563021138586.png" alt="1563021138586" loading="lazy"></figure>
<h3 id="23-小结">2.3 小结</h3>
<ul>
<li>
<p>RPC和HTTP的区别：RPC是根据语言API来定义，而不是根据基于网络的应用来定义。</p>
</li>
<li>
<p>RestTemplate:</p>
<p>①RestTemplate是Rest的HTTP客户端模板工具类。</p>
<p>②对基于Http的客户端进行封装。</p>
<p>③实现对象与JSON的序列化与反序列化。</p>
<p>④不限定客户端类型</p>
</li>
<li>
<p>RestTemplate的使用</p>
<pre><code class="language-properties">创建一个RestTemplate，将该对象实例给SpringIOC容器管理
@Bean
public RestTemplate restTemplate(){
    return new RestTemplate();
}

restTemplate.getForObject(url,String.class);
</code></pre>
</li>
</ul>
<h2 id="3-模拟微服务业务场景">3 模拟微服务业务场景</h2>
<p>模拟开发过程中的服务间关系。抽象出来，开发中的微服务之间的关系是生产者和消费者关系。</p>
<p><strong>总目标：模拟一个最简单的服务调用场景，场景中保护微服务提供者(Producer)和微服务调用者(Consumer)</strong>，方便后面学习微服务架构</p>
<p><strong>注意：实际开发中，每个微服务为一个独立的SpringBoot工程。</strong></p>
<figure data-type="image" tabindex="10"><img src="images%5C1563027834881.png" alt="1563027834881" loading="lazy"></figure>
<h3 id="31-目标">3.1 目标</h3>
<ul>
<li>
<p>创建父工程</p>
</li>
<li>
<p>搭建服务提供者</p>
</li>
<li>
<p>搭建服务消费者</p>
</li>
<li>
<p>服务消费者使用RestTemplate调用服务提供者</p>
</li>
</ul>
<h3 id="32-讲解">3.2 讲解</h3>
<h4 id="321-创建父工程">3.2.1 创建父工程</h4>
<p>(1)新建工程</p>
<p>新建一个Maven父工程<code>springcloud-parent</code>,创建步骤如下：</p>
<figure data-type="image" tabindex="11"><img src="images%5C1563027911022.png" alt="1563027911022" loading="lazy"></figure>
<figure data-type="image" tabindex="12"><img src="images%5C1563027956557.png" alt="1563027956557" loading="lazy"></figure>
<figure data-type="image" tabindex="13"><img src="images%5C1563027999119.png" alt="1563027999119" loading="lazy"></figure>
<p>（2）引入依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;

    &lt;groupId&gt;com.itheima&lt;/groupId&gt;
    &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;
    &lt;packaging&gt;pom&lt;/packaging&gt;
    &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;modules&gt;
        &lt;module&gt;user-provider&lt;/module&gt;
        &lt;module&gt;user-consumer&lt;/module&gt;
    &lt;/modules&gt;

    &lt;!--父工程--&gt;
    &lt;parent&gt;
        &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
        &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt;
        &lt;version&gt;2.1.6.RELEASE&lt;/version&gt;
    &lt;/parent&gt;
    &lt;!--SpringCloud包依赖管理--&gt;
    &lt;dependencyManagement&gt;
        &lt;dependencies&gt;
            &lt;dependency&gt;
                &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
                &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt;
                &lt;version&gt;Greenwich.SR1&lt;/version&gt;
                &lt;type&gt;pom&lt;/type&gt;
                &lt;scope&gt;import&lt;/scope&gt;
            &lt;/dependency&gt;
        &lt;/dependencies&gt;
    &lt;/dependencyManagement&gt;
&lt;/project&gt;
</code></pre>
<h4 id="322-创建服务提供者producer工程">3.2.2 创建服务提供者(producer)工程</h4>
<p>每个微服务工程都是独立的工程，连数据库都是独立的，所以我们一会要单独为该服务工程创建数据库。</p>
<p>工程创建步骤：</p>
<pre><code class="language-properties">1.准备表结构
2.创建工程
3.引入依赖
4.创建Pojo，需要配置JPA的注解
5.创建Dao，需要继承JpaRepository&lt;T,ID&gt;
6.创建Service，并调用Dao
7.创建Controller，并调用Service
8.创建application.yml文件
9.创建启动类
10.测试
</code></pre>
<p>(1)建表</p>
<p>producer工程是一个独立的微服务，一般拥有独立的controller、service、dao、数据库，我们在springcloud数据库新建表结构信息，如下：</p>
<pre><code class="language-sql">-- 使用springcloud数据库
USE springcloud;
-- ----------------------------
-- Table structure for tb_user
-- ----------------------------
CREATE TABLE `tb_user` (
  `id` int(11) NOT NULL AUTO_INCREMENT,
  `username` varchar(100) DEFAULT NULL COMMENT '用户名',
  `password` varchar(100) DEFAULT NULL COMMENT '密码',
  `name` varchar(100) DEFAULT NULL COMMENT '姓名',
  `age` int(11) DEFAULT NULL COMMENT '年龄',
  `sex` int(11) DEFAULT NULL COMMENT '性别，1男，2女',
  `birthday` date DEFAULT NULL COMMENT '出生日期',
  `created` date DEFAULT NULL COMMENT '创建时间',
  `updated` date DEFAULT NULL COMMENT '更新时间',
  `note` varchar(1000) DEFAULT NULL COMMENT '备注',
  PRIMARY KEY (`id`)
) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='用户信息表';
-- ----------------------------
-- Records of tb_user
-- ----------------------------
INSERT INTO `tb_user` VALUES ('1', 'zhangsan', '123456', '张三', '13', '1', '2006-08-01', '2019-05-16', '2019-05-16', '张三');
INSERT INTO `tb_user` VALUES ('2', 'lisi', '123456', '李四', '13', '1', '2006-08-01', '2019-05-16', '2019-05-16', '李四');
</code></pre>
<p>(2)新建user-provider工程</p>
<p>选中springcloud-parent工程-&gt;New Modul-&gt;Maven-&gt;输入坐标名字，如下步骤：</p>
<figure data-type="image" tabindex="14"><img src="images%5C1563028264001.png" alt="1563028264001" loading="lazy"></figure>
<figure data-type="image" tabindex="15"><img src="images%5C1563028308366.png" alt="1563028308366" loading="lazy"></figure>
<p>引入pom.xml依赖</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;
        &lt;groupId&gt;com.itheima&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;artifactId&gt;user-provider&lt;/artifactId&gt;

    &lt;!--依赖包--&gt;
    &lt;dependencies&gt;
        &lt;!--JPA包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--web起步包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
        &lt;!--MySQL驱动包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;mysql&lt;/groupId&gt;
            &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;
            &lt;scope&gt;runtime&lt;/scope&gt;
        &lt;/dependency&gt;
        &lt;!--测试包--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt;
            &lt;scope&gt;test&lt;/scope&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>(3)User对象创建</p>
<p>创建<code>com.itheima.domain.User</code>，代码如下：</p>
<pre><code class="language-java">@Entity
@Table(name = &quot;tb_user&quot;)
public class User implements Serializable{
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Integer id;//主键id
    private String username;//用户名
    private String password;//密码
    private String name;//姓名
    private Integer age;//年龄
    private Integer sex;//性别 1男性，2女性
    private Date birthday; //出生日期
    private Date created; //创建时间
    private Date updated; //更新时间
    private String note;//备注
    //..set get toString 略
}
</code></pre>
<p>(4)dao<br>
创建<code>com.itheima.dao.UserDao</code>，代码如下：</p>
<pre><code class="language-java">public interface UserDao extends JpaRepository&lt;User,Integer&gt; {
}
</code></pre>
<p>(5)Service层</p>
<p>创建<code>com.itheima.service.UserService</code>接口，代码如下：</p>
<pre><code class="language-java">public interface UserService {
    /***
     * 根据ID查询用户信息
     * @param id
     * @return
     */
    User findByUserId(Integer id);
}
</code></pre>
<p>创建<code>com.itheima.service.impl.UserServiceImpl</code>代码如下：</p>
<pre><code class="language-java">@Service
public class UserServiceImpl implements UserService {

    @Autowired
    private UserDao userDao;

    /***
     * 根据ID查询用户信息
     * @param id
     * @return
     */
    @Override
    public User findByUserId(Integer id) {
        return userDao.findById(id).get();
    }
}
</code></pre>
<p>(6)控制层</p>
<p>创建<code>com.itheima.controller.UserController</code>，代码如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(value = &quot;/user&quot;)
public class UserController {

    @Autowired
    private UserService userService;

    /***
     * 根据ID查询用户信息
     * @param id
     * @return
     */
    @RequestMapping(value = &quot;/find/{id}&quot;)
    public User findById(@PathVariable(value = &quot;id&quot;) Integer id){
        return userService.findByUserId(id);
    }
}
</code></pre>
<p>(7)application.yml配置</p>
<pre><code class="language-properties">server:
  port: 18081
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: root
    url: jdbc:mysql://127.0.0.1:3306/springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
</code></pre>
<p>(8)启动类创建</p>
<p>创建<code>com.itheima.UserProviderApplication</code>启动类，并启动</p>
<pre><code class="language-java">@SpringBootApplication
public class UserProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserProviderApplication.class,args);
    }
}
</code></pre>
<p>测试：<code>&lt;http://localhost:18081/user/find/2&gt;</code></p>
<figure data-type="image" tabindex="16"><img src="images%5C1563028849102.png" alt="1563028849102" loading="lazy"></figure>
<h4 id="323-创建服务消费者consumer工程">3.2.3 创建服务消费者(consumer)工程</h4>
<p>在该工程中使用RestTemplate来调用user-provider微服务。</p>
<p>实现步骤：</p>
<pre><code class="language-properties">1.创建工程
2.引入依赖
3.创建Pojo
4.创建启动类，同时创建RestTemplate对象，并交给SpringIOC容器管理
5.创建application.yml文件，指定端口
6.编写Controller，在Controller中通过RestTemplate调用user-provider的服务
7.启动测试
</code></pre>
<p>(1)工程搭建</p>
<p>选中springcloud-parent工程-&gt;New Modul-&gt;Maven-&gt;输入坐标名字，如下步骤：</p>
<figure data-type="image" tabindex="17"><img src="images%5C1563028974269.png" alt="1563028974269" loading="lazy"></figure>
<figure data-type="image" tabindex="18"><img src="images%5C1563029007419.png" alt="1563029007419" loading="lazy"></figure>
<p>pom.xml依赖如下：</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;
        &lt;groupId&gt;com.itheima&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;artifactId&gt;user-consumer&lt;/artifactId&gt;

    &lt;!--依赖包--&gt;
    &lt;dependencies&gt;
        &lt;!--web起步依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;
            &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>(2)创建User对象</p>
<p>在src下创建<code>com.itheima.domain.User</code>,代码如下：</p>
<pre><code class="language-java">public class User implements Serializable{
    private Integer id;//主键id
    private String username;//用户名
    private String password;//密码
    private String name;//姓名
    private Integer age;//年龄
    private Integer sex;//性别 1男性，2女性
    private Date birthday; //出生日期
    private Date created; //创建时间
    private Date updated; //更新时间
    private String note;//备注
    
    //..set、get、toString 略
}
</code></pre>
<p>(3)创建启动引导类</p>
<p>在src下创建<code>com.itheima.UserConsumerApplication</code>,代码如下：</p>
<pre><code class="language-java">@SpringBootApplication
public class UserConsumerApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserConsumerApplication.class,args);
    }

    /***
     * 将RestTemplate的实例放到Spring容器中
     * @return
     */
    @Bean
    public RestTemplate restTemplate(){
        return new RestTemplate();
    }
}
</code></pre>
<p>创建application.yml,并配置端口为18082</p>
<pre><code class="language-properties">server:
  port: 18082
</code></pre>
<p>(4)创建控制层，在控制层中调用user-provider</p>
<p>在src下创建<code>com.itheima.controller.UserController</code>，代码如下：</p>
<pre><code class="language-java">@RestController
@RequestMapping(value = &quot;/consumer&quot;)
public class UserController {
    @Autowired
    private RestTemplate restTemplate;

    /**
     * 在user-consumer服务中通过RestTemplate调用user-provider服务
     * @param id
     * @return
     */
    @GetMapping(value = &quot;/{id}&quot;)
    public User queryById(@PathVariable(value = &quot;id&quot;)Integer id){
        String url = &quot;http://localhost:18081/user/find/&quot;+id;
        return restTemplate.getForObject(url,User.class);
    }
}
</code></pre>
<p>启动测试：</p>
<p>请求地址：<code>&lt;http://localhost:18082/consumer/1&gt;</code></p>
<figure data-type="image" tabindex="19"><img src="images%5C1563029284043.png" alt="1563029284043" loading="lazy"></figure>
<h4 id="324-思考问题">3.2.4 思考问题</h4>
<p>user-provider：对外提供用户查询接口</p>
<p>user-consumer：通过RestTemplate访问接口查询用户数据</p>
<p>存在的问题：</p>
<ol>
<li>在服务消费者中，我们把url地址硬编码到代码中，不方便后期维护</li>
<li>在服务消费者中，不清楚服务提供者的状态(user-provider有可能没有,或者说宕机了)</li>
<li>服务提供者只有一个服务，即便服务提供者形成<strong>集群</strong>，服务消费者还需要自己实现<strong>负载均衡</strong></li>
<li>服务提供者如果出现故障，是否能够及时发现：</li>
</ol>
<p>其实上面说的问题，概括一下就是微服务架构必然要面临的问题</p>
<ul>
<li>服务管理：自动注册与发现、状态监管</li>
<li>服务负载均衡</li>
<li>等等</li>
</ul>
<h3 id="33-小结">3.3 小结</h3>
<ul>
<li>服务消费者使用RestTemplate调用服务提供者,使用RestTemplate调用的时候，需要先创建并注入到SpringIOC容器中</li>
<li>在服务消费者中，我们把url地址硬编码到代码中，不方便后期维护</li>
<li>在服务消费者中，不清楚服务提供者的状态(user-provider有可能没有,或者宕机了)</li>
<li>服务提供者只有一个服务，即便服务提供者形成集群，服务消费者还需要自己实现负载均衡</li>
<li>服务提供者的如果出现故障，不能及时发现。</li>
</ul>
<h2 id="4-注册中心-spring-cloud-eureka"><mark>4 注册中心 Spring Cloud Eureka</mark></h2>
<p>前面我们学过Dubbo，关于Dubbo的执行过程我们看如下图片：</p>
<figure data-type="image" tabindex="20"><img src="images%5C1555072467639.png" alt="" loading="lazy"></figure>
<p>执行过程：</p>
<pre><code class="language-properties">1.Provider:服务提供者,异步将自身信息注册到Register（注册中心）
2.Consumer：服务消费者，异步去Register中拉取服务数据
3.Register异步推送服务数据给Consumer,如果有新的服务注册了，Consumer可以直接监控到新的服务
4.Consumer同步调用Provider
5.Consumer和Provider异步将调用频率信息发给Monitor监控
</code></pre>
<h3 id="41-目标">4.1 目标</h3>
<ul>
<li>理解Eureka的原理图-服务注册与发现中心</li>
<li>能实现Eureka服务的搭建</li>
<li>能实现服务提供者向Eureka注册服务</li>
<li>能实现服务消费者向Eureka注册服务</li>
<li>能实现消费者通过Eureka访问服务提供者</li>
<li><mark>能掌握Eureka的详细配置</mark></li>
</ul>
<h3 id="42-讲解">4.2 讲解</h3>
<h4 id="421-eureka-简介">4.2.1 Eureka 简介</h4>
<p>Eureka解决了第一个问题(<mark>作用</mark>)：服务的管理，注册和发现、状态监管、动态路由。</p>
<p>Eureka负责管理记录服务提供者的信息。服务调用者(消费者)无需自己寻找服务，Eureka自动匹配服务给调用者。</p>
<p>Eureka与服务之间通过<code>心跳</code>机制进行监控；</p>
<h4 id="422-原理图">4.2.2 原理图</h4>
<p>基本架构图</p>
<figure data-type="image" tabindex="21"><img src="images%5C1563089431796.png" alt="1563089431796" loading="lazy"></figure>
<p>Eureka：就是服务注册中心(可以是一个集<strong>群</strong>)，对外暴露自己的地址</p>
<p>服务提供者：启动后向Eureka注册自己的信息(地址，提供什么服务)</p>
<p>服务消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</p>
<p>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</p>
<h4 id="423-入门案例">4.2.3 入门案例</h4>
<p>目标：搭建Eureka Server环境，创建一个eureka_server工程。</p>
<p>**步骤：**分三步</p>
<pre><code class="language-properties">1：eureka-serve搭建工程eureka-server
2：服务提供者-注册服务，user-provider工程
3：服务消费者-发现服务，user-consumer工程
</code></pre>
<h5 id="4231-搭建eureka-server工程">4.2.3.1 搭建eureka-server工程</h5>
<p>(1)工程搭建</p>
<p>选中springcloud-parent工程-&gt;New Modul-&gt;Maven-&gt;输入坐标名字，如下步骤：</p>
<figure data-type="image" tabindex="22"><img src="images%5C1563093804303.png" alt="1563093804303" loading="lazy"></figure>
<figure data-type="image" tabindex="23"><img src="images%5C1563093844890.png" alt="1563093844890" loading="lazy"></figure>
<p>(2)pom.xml引入依赖,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓</p>
<pre><code class="language-xml">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;
&lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot;
         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;
         xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt;
    &lt;parent&gt;
        &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt;
        &lt;groupId&gt;com.itheima&lt;/groupId&gt;
        &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt;
    &lt;/parent&gt;
    &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt;
    &lt;artifactId&gt;eureka-server&lt;/artifactId&gt;

    &lt;!--依赖包,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓--&gt;
    &lt;dependencies&gt;
        &lt;!--eureka-server依赖--&gt;
        &lt;dependency&gt;
            &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
            &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt;
        &lt;/dependency&gt;
    &lt;/dependencies&gt;
&lt;/project&gt;
</code></pre>
<p>(3)application.yml配置,打个url提示,然后点击service-url跑到一个类指定它是map,给它赋值键和值即可↓</p>
<pre><code class="language-properties">server:
  port: 7001    #端口号
spring:
  application:
    name: eureka-server # 应用名称，会在Eureka中作为服务的id标识（serviceId）
eureka:
  client:
    register-with-eureka: false   #是否将自己注册到Eureka中
    fetch-registry: false   #是否从eureka中获取服务信息
    service-url:
      defaultZone: http://localhost:7001/eureka # EurekaServer的地址
</code></pre>
<p>(4)启动类创建</p>
<p>在src下创建<code>com.itheima.EurekaServerApplication</code>,在类上需要添加一个注解<code>@EnableEurekaServer</code>，用于开启Eureka服务,代码如下：</p>
<pre><code class="language-java">@SpringBootApplication
@EnableEurekaServer //开启Eureka服务
public class EurekaServerApplication {
    public static void main(String[] args) {
        SpringApplication.run(EurekaServerApplication.class,args);
    }
}
</code></pre>
<p>(5)启动访问</p>
<p>启动后，访问<code>&lt;http://127.0.0.1:7001/&gt;</code>，效果如下：</p>
<figure data-type="image" tabindex="24"><img src="images%5C1563094286893.png" alt="1563094286893" loading="lazy"></figure>
<h5 id="4232-服务提供者-注册服务">4.2.3.2 服务提供者-注册服务</h5>
<p>我们的user-provider属于服务提供者，需要在user-provider工程中引入Eureka客户端依赖，然后在配置文件中指定Eureka服务地址,然后在启动类中开启Eureka服务发现功能(开启Eureka客户端功能)。</p>
<p>步骤：</p>
<pre><code class="language-properties">1.引入eureka客户端依赖包
2.在application.yml中配置Eureka服务地址
3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient 
</code></pre>
<p>(1)引入依赖</p>
<p>在user-provider的pom.xml中引入如下依赖,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓</p>
<pre><code class="language-xml">&lt;!--eureka客户端--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>(2)配置Eureka服务地址</p>
<p>修改user-provider的application.yml配置文件，添加Eureka服务地址，代码如下：</p>
<figure data-type="image" tabindex="25"><img src="images%5C1563097201829.png" alt="1563097201829" loading="lazy"></figure>
<p>上图代码如下：客户端配置抄服务器的,去掉注册和抓取配置,然后修改端口和应用名即可↓</p>
<pre><code class="language-yaml">server:
  port: 18081
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    username: root
    password: root
    url: jdbc:mysql://127.0.0.1:3306/springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC
  application:
    name: user-provider #服务的名字,不同的应用，名字不同，如果是集群，名字需要相同
#指定eureka服务地址
eureka:
  client:
    service-url:
      # EurekaServer的地址
      defaultZone: http://localhost:7001/eureka
</code></pre>
<p>(3)开启Eureka客户端发现功能</p>
<p>在user-provider的启动类<code>com.itheima.UserProviderApplication</code>上添加<code>@EnableDiscoveryClient</code>注解或者<code>@EnableEurekaClient</code>，用于开启客户端发现功能。</p>
<pre><code class="language-java">@SpringBootApplication
//@EnableDiscoveryClient//开启Eureka客户端发现功能
@EnableEurekaClient     //开启Eureka客户端发现功能，注册中心只能是Eureka
public class UserProviderApplication {
    public static void main(String[] args) {
        SpringApplication.run(UserProviderApplication.class,args);
    }
}
</code></pre>
<p>区别：</p>
<p><code>@EnableDiscoveryClient</code>和<code>@EnableEurekaClient</code>都用于开启客户端的发现功能，但<code>@EnableEurekaClient</code>的注册中心只能是Eureka。</p>
<p>(4)启动测试</p>
<p>启动eureka-server，再启动user-provider。</p>
<p>访问Eureka地址<code>&lt;http://127.0.0.1:7001/&gt;</code>，效果如下：</p>
<figure data-type="image" tabindex="26"><img src="images%5C1563097634851.png" alt="1563097634851" loading="lazy"></figure>
<h5 id="4233-服务消费者-注册服务中心">4.2.3.3 服务消费者-注册服务中心</h5>
<p>消费方添加Eureka服务注册和生产方配置流程一致。</p>
<p>步骤：</p>
<pre><code class="language-properties">1.引入eureka客户端依赖包
2.在application.yml中配置Eureka服务地址
3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient 
</code></pre>
<p>(1)pom.xml引入依赖</p>
<p>修改user-consumer的pom.xml引入如下依赖,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓</p>
<pre><code class="language-xml">&lt;!--eureka客户端--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p>(2)application.yml中配置eureka服务地址</p>
<p>修改user-consumer工程的application.yml配置，添加eureka服务地址，配置如下：</p>
<figure data-type="image" tabindex="27"><img src="images%5C1563098000059.png" alt="1563098000059" loading="lazy"></figure>
<p>上图配置如下：客户端配置抄服务器的,去掉注册和抓取配置,然后修改端口和应用名即可↓</p>
<pre><code class="language-properties">server:
  port: 18082
spring:
  application:
    name: user-consumer   #服务名字
#指定eureka服务地址
eureka:
  client:
    service-url:
      # EurekaServer的地址
      defaultZone: http://localhost:7001/eureka
</code></pre>
<p>(3)在启动类上开启Eureka服务发现功能</p>
<p>修改user-consumer的<code>com.itheima.UserConsumerApplication</code>启动类，在类上添加<code>@EnableDiscoveryClient</code>注解，代码如下：</p>
<figure data-type="image" tabindex="28"><img src="images%5C1563098256837.png" alt="1563098256837" loading="lazy"></figure>
<p>上图代码如下：</p>
<pre><code class="language-java">@SpringBootApplication
@EnableDiscoveryClient  //开启Eureka客户端发现功能
public class UserConsumerApplication {
 	public static void main(String[] args) {
        SpringApplication.run(UserConsumerApplication.class,args);
    }
}
</code></pre>
<p>(4)测试</p>
<p>启动user-consumer，然后访问Eureka服务地址<code>&lt;http://127.0.0.1:7001/&gt;</code>效果如下：</p>
<figure data-type="image" tabindex="29"><img src="images%5C1563098399496.png" alt="1563098399496" loading="lazy"></figure>
<h5 id="4234-消费者作为客户端通过eureka服务器拿到提供者注册的数据即ip和端口等去访问服务提供者">4.2.3.4 消费者作为客户端通过Eureka服务器拿到提供者注册的数据即ip和端口等,去访问服务提供者</h5>
<p>之前消费者<code>user-consumer</code>访问服务提供者<code>user-provider</code>是通过<code>http://localhost:18081/user/find/1</code>访问的，这里是具体的路径，没有从Eureka获取访问地址，我们可以让消费者从Eureka那里获取服务提供者的访问地址，然后访问服务提供者。</p>
<p>修改user-consumer的<code>com.itheima.controller.UserController</code>，代码如下：</p>
<figure data-type="image" tabindex="30"><img src="images%5C1563098992272.png" alt="1563098992272" loading="lazy"></figure>
<p>Debug跟踪运行，访问<code>&lt;http://localhost:18082/consumer/1&gt;</code>，效果如下：</p>
<figure data-type="image" tabindex="31"><img src="assets/1603337767375.png" alt="1603337767375" loading="lazy"></figure>
<p>跟踪运行后，我们发现，这里的地址就是服务注册中的状态名字↓</p>
<figure data-type="image" tabindex="32"><img src="assets/1603337295610.png" alt="1603337295610" loading="lazy"></figure>
<p>浏览器结果如下：</p>
<figure data-type="image" tabindex="33"><img src="images%5C1563099333167.png" alt="1563099333167" loading="lazy"></figure>
<p>(2)使用IP访问配置</p>
<p>上面的请求地址是服务状态名字，其实也是当前被访问主机的名字，可以通过配置文件，将它换成IP，修改<strong>提供者</strong>的application.yml配置文件，代码如下：</p>
<figure data-type="image" tabindex="34"><img src="images%5C1563100045968.png" alt="1563100045968" loading="lazy"></figure>
<p>上图配置如下：打个ip提示即可↓</p>
<pre><code class="language-yaml">  instance:
    #指定IP地址
    ip-address: 127.0.0.1
    #访问服务的时候，推荐使用IP
    prefer-ip-address: true
</code></pre>
<p>重新启动<code>user-provider</code>，有时候消费者有缓存,所以<strong>消费者也要重启</strong>!然后通过消费者再次访问，测试效果如下：</p>
<figure data-type="image" tabindex="35"><img src="assets/1603337925303.png" alt="1603337925303" loading="lazy"></figure>
<p>通过上面的测试,说明restTemplate确实能通过应用服务名user-provider来得到服务器上的提供者的ip和端口,如果你给我加上加载平衡注解,那么我就自动做了!</p>
<h4 id="424-eureka详解">4.2.4 Eureka详解</h4>
<h5 id="4241-基础架构">4.2.4.1 基础架构</h5>
<p>Eureka架构中的三个核心角色</p>
<pre><code class="language-properties">1.服务注册中心：Eureka服务端应用，提供服务注册发现功能，eureka-server
2.服务提供者：提供服务的应用
  要求统一对外提供Rest风格的服务即可
  本例子：user-provider
3.服务消费者：从注册中心获取服务列表，知道去哪调用服务提供者，user-consumer
</code></pre>
<h5 id="4242-eureka客户端">4.2.4.2 Eureka客户端</h5>
<p><strong>服务提供者</strong>要向EurekaServer注册服务，并完成服务<strong>续约</strong>等工作</p>
<p><strong>服务注册:</strong></p>
<pre><code class="language-properties">1. 当我们开启了客户端发现注解@DiscoveryClient。同时导入了eureka-client依赖坐标
2. 同时配置Eureka服务注册中心地址在配置文件中
3. 服务在启动时，检测是否有@DiscoveryClient注解和配置信息
4. 如果有，则会向注册中心发起注册请求，携带服务元数据信息(IP、端口等)到注册中心
5. Eureka注册中心会把服务的信息保存在它的Map中(万能map)。
</code></pre>
<p><strong>服务续约：</strong></p>
<p>服务注册完成以后，<strong>服务提供者</strong>会维持一个<code>心跳</code>，保证服务处于存在状态。这个称之为服务提供者续约(renew)。</p>
<figure data-type="image" tabindex="36"><img src="images%5C1563102805802.png" alt="1563102805802" loading="lazy"></figure>
<p>上图配置如下：打个lease提示即可↓</p>
<pre><code class="language-yaml">eureka:
  client:
    service-url:
      # EurekaServer的地址
      defaultZone: http://localhost:7001/eureka
  instance:
    #指定IP地址
    ip-address: 127.0.0.1
    #访问服务的时候，推荐使用IP
    prefer-ip-address: true
    #租约到期，服务时效时间，默认值90秒
    lease-expiration-duration-in-seconds: 15
    #租约续约间隔时间，默认30秒
    lease-renewal-interval-in-seconds: 40
</code></pre>
<p>**获取服务列表：**注册抓取间隔时间配置,了解</p>
<figure data-type="image" tabindex="37"><img src="images%5C1563102910373.png" alt="1563102910373" loading="lazy"></figure>
<p>上图配置如下：打个registry或者fetch提示即可↓</p>
<pre><code class="language-yaml">registry-fetch-interval-seconds: 30
</code></pre>
<p>说明：</p>
<pre><code class="language-properties">服务消费者启动时，会检测是否获取到服务注册信息配置
如果是，则会从 EurekaServer获取服务列表只读备份，缓存到消费者本地
每隔30秒，会重新获取并更新数据
每隔30秒的时间可以通过配置registry-fetch-interval-seconds修改
</code></pre>
<h5 id="4243-失效剔除和自我保护">4.2.4.3 失效剔除和自我保护</h5>
<p><strong>服务下线：</strong></p>
<pre><code>当服务正常关闭时，会发送服务下线的REST请求给EurekaServer。
服务中心接受到请求后，将该服务置为下线状态
</code></pre>
<p><strong>失效剔除：</strong></p>
<pre><code>服务注册中心,每隔一段时间(默认60秒)将列表清单中没有续约的服务剔除。
通过eviction-interval-timer-in-ms配置可以对其进行修改，单位是毫秒
</code></pre>
<p>剔除时间配置</p>
<figure data-type="image" tabindex="38"><img src="images%5C1563103529735.png" alt="1563103529735" loading="lazy"></figure>
<p>上图代码如下：自我保护和剔除时间,打个se提示即可↓</p>
<pre><code class="language-yaml">eureka:
  client:
    register-with-eureka: false   #是否将自己注册到Eureka中
    fetch-registry: false   #是否从eureka中获取服务信息
    service-url:
      defaultZone: http://localhost:7001/eureka # EurekaServer的地址
  server:
    enable-self-preservation: false
    eviction-interval-timer-in-ms: 5000
</code></pre>
<p><strong>自我保护：</strong></p>
<p>Eureka会统计服务提供者实例,最近<strong>15分钟</strong>心跳续约的比例是否低于<strong>85%，如果低于</strong>则会触发自我保护机制。</p>
<p>服务中心页面会显示如下提示信息(很容易理解,正常情况下,你服务提供者每隔30秒续约,但是你的比例太低说明你可能遇到了其他不可控的因素,比如网络问题,那我注册中心肯定不会把你的数据剔除,开启自我保护)</p>
<figure data-type="image" tabindex="39"><img src="images%5C1558056004897.png" alt="1558056004897" loading="lazy"></figure>
<p>含义：紧急情况！Eureka可能错误地声称实例已经启动，而事实并非如此。续约低于阈值(yu)，因此实例不会为了安全而过期。</p>
<pre><code class="language-properties">1.自我保护模式下，不会剔除任何服务实例
2.自我保护模式保证了大多数服务依然可用(比如为了应对服务提供者网络突然中断的问题等)
3.通过enable-self-preservation配置可用关停自我保护，默认值是打开的
</code></pre>
<p>关闭自我保护</p>
<figure data-type="image" tabindex="40"><img src="images%5C1563103437025.png" alt="1563103437025" loading="lazy"></figure>
<p>上图配置如下,即Eureka服务器关闭自我保护机制：</p>
<pre><code class="language-yaml">server:
	enable-self-preservation: false
</code></pre>
<h3 id="43-小结">4.3 小结</h3>
<ul>
<li>
<p>理解Eureka的原理图:</p>
<pre><code class="language-properties">Eureka：就是服务注册中心(可以是一个集群)，对外暴露自己的地址
服务提供者：启动后向Eureka注册自己的信息(地址，提供什么服务)
服务消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新
心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态
</code></pre>
</li>
<li>
<p>能实现Eureka服务的搭建:引入依赖包，配置配置文件，在启动类上加<code>@EnableEurekaServer</code>。</p>
</li>
<li>
<p>能实现服务提供者向Eureka注册服务</p>
<pre><code class="language-properties">1.引入eureka客户端依赖包
2.在application.yml中配置Eureka服务地址
3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient 
</code></pre>
</li>
<li>
<p>能实现服务消费者向Eureka注册服务</p>
<pre><code class="language-properties">1.引入eureka客户端依赖包
2.在application.yml中配置Eureka服务地址
3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient 
</code></pre>
</li>
<li>
<p>能实现消费者通过Eureka访问服务提供者</p>
</li>
<li>
<p><mark>最重要的是配置小结,关于配置,一般都在服务提供者,有两个节点,client节点配置客户端信息比如url,instance实例节点配置服务相关信息,这个节点配置比较多比如ip或者lease,如下所示:↓</mark></p>
<pre><code class="language-yaml">server:
  port: 18081
spring:
  datasource:
    driver-class-name: com.mysql.cj.jdbc.Driver
    url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC
    username: root
    password: root
  application:
    name: user-provider
eureka:
  client:
    service-url:
      defaultZone: http://localhost:7001/eureka/
    registry-fetch-interval-seconds: 30
  instance:
    prefer-ip-address: true
#    ip-address: localhost
    ip-address: 127.0.0.1
    lease-expiration-duration-in-seconds: 9
    lease-renewal-interval-in-seconds: 30
</code></pre>
</li>
<li>
<p><mark>另外服务注册中心还多了一个server服务节点,一般用来配置关闭自我保护和剔除时间,如下:↓</mark></p>
<pre><code class="language-yaml">server:
  port: 7001    #端口号
spring:
  application:
    name: eureka-server # 应用名称，会在Eureka中作为服务的id标识（serviceId）
eureka:
  client:
    register-with-eureka: false   #是否将自己注册到Eureka中
    fetch-registry: false   #是否从eureka中获取服务信息
    service-url:
      defaultZone: http://localhost:7001/eureka
  server:
    enable-self-preservation: false
    eviction-interval-timer-in-ms: 5000 # EurekaServer的地址
</code></pre>
</li>
<li>
<p><mark>到这里有些同学就有想法了,难道消费者不用配置其他东西了嘛?那你错了,接下来的客户端负载均衡,服务降级都是消费者方面的配置!咱们拭目以待↓</mark></p>
</li>
</ul>
<h2 id="5-负载均衡-spring-cloud-ribbon"><mark>5 负载均衡 Spring Cloud Ribbon</mark></h2>
<p>Ribbon主要 解决如多个服务提供者,集群服务中，多个服务高效率访问的问题。</p>
<h3 id="51-目标">5.1 目标</h3>
<ul>
<li>理解Ribbon的负载均衡应用场景</li>
<li>能实现Ribbon的轮询、随机算法配置</li>
<li>理解源码对负载均衡的切换</li>
</ul>
<h3 id="52-讲解">5.2 讲解</h3>
<h4 id="521-ribbon-简介">5.2.1 Ribbon 简介</h4>
<p>什么是Ribbon？</p>
<p>Ribbon是Netflix发布的<strong>负载均衡器</strong>，有助于<strong>控制HTTP客户端行为</strong>。为Ribbon配置服务提供者地址列表后，Ribbon就可基于负载均衡算法，自动帮助服务消费者请求。</p>
<p>Ribbon默认提供的负载均衡算法：<mark>轮询(默认)</mark>，<mark>随机</mark>,重试法,加权。当然，我们可用自己定义负载均衡算法</p>
<h4 id="522-入门案例">5.2.2 入门案例</h4>
<h5 id="5221-多个服务集群">5.2.2.1 多个服务集群</h5>
<figure data-type="image" tabindex="41"><img src="images%5C1563110459400.png" alt="1563110459400" loading="lazy"></figure>
<p>如果想要做负载均衡，我们的服务至少2个以上,为了演示负载均衡案例，我们可以复制2个工程，分别为<code>user-provider</code>和<code>user-provider-demo1</code>，可以按照如下步骤拷贝工程：</p>
<p>①选中<code>user-provider</code>,按<code>Ctrl+C</code>，然后<code>Ctrl+V</code></p>
<figure data-type="image" tabindex="42"><img src="images%5C1563110649115.png" alt="1563110649115" loading="lazy"></figure>
<p>②名字改成<code>user-provider-demo1</code>,点击OK</p>
<figure data-type="image" tabindex="43"><img src="images%5C1563110738488.png" alt="1563110738488" loading="lazy"></figure>
<p>③将<code>user-provider-demo1</code>的<code>artifactId</code>换成<code>user-provider-demo1</code></p>
<figure data-type="image" tabindex="44"><img src="images%5C1563110842156.png" alt="1563110842156" loading="lazy"></figure>
<p>④在springcloud-parent的pom.xml中添加一个<code>&lt;module&gt;user-provider-demo1&lt;/module&gt;</code></p>
<figure data-type="image" tabindex="45"><img src="images%5C1563110990061.png" alt="1563110990061" loading="lazy"></figure>
<p>⑤将<code>user-provider-demo1</code>的application.yml中的端口改成18083</p>
<figure data-type="image" tabindex="46"><img src="images%5C1563111191901.png" alt="1563111191901" loading="lazy"></figure>
<p>为了方便测试，将2个工程对应的<code>com.itheima.controller.UserController</code>都修改一下：</p>
<p><code>user-provider</code>:</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/find/{id}&quot;)
public User findById(@PathVariable(value = &quot;id&quot;) Integer id){
    User user = userService.findByUserId(id);
    user.setUsername(user+&quot;     user-provider&quot;);
    return user;
}
</code></pre>
<p><code>user-provider-demo1</code>:</p>
<pre><code class="language-java">@RequestMapping(value = &quot;/find/{id}&quot;)
public User findById(@PathVariable(value = &quot;id&quot;) Integer id){
    User user = userService.findByUserId(id);
    user.setUsername(user+&quot;     user-provider-demo1&quot;);
    return user;
}
</code></pre>
<p><mark>⑥启动<code>eureka-server</code>和<code>user-provider</code>、<code>user-provider-demo1</code>、<code>user-consumer</code>，启动前先注释掉<code>eureka-server</code>中的自我保护和剔除服务配置。</mark></p>
<figure data-type="image" tabindex="47"><img src="images%5C1563111434062.png" alt="1563111434062" loading="lazy"></figure>
<p>访问<code>eureka-server</code>地址<code>&lt;http://127.0.0.1:7001/&gt;</code>效果如下：</p>
<figure data-type="image" tabindex="48"><img src="images%5C1563111556883.png" alt="1563111556883" loading="lazy"></figure>
<h5 id="5222-开启负载均衡">5.2.2.2 开启负载均衡</h5>
<p>(1)客户端开启负载均衡</p>
<p>Eureka已经集成Ribbon，所以无需引入依赖,要想使用Ribbon，直接在RestTemplate的配置方法上添加<code>@LoadBalanced</code>注解即可</p>
<p>修改<code>user-consumer</code>的<code>com.itheima.UserConsumerApplication</code>启动类，<mark>在<code>restTemplate()</code>方法上添加<code>@LoadBalanced</code>注解</mark>，代码如下：</p>
<figure data-type="image" tabindex="49"><img src="images%5C1563112003073.png" alt="1563112003073" loading="lazy"></figure>
<p>(2)采用<mark>服务提供者服务名访问</mark>配置</p>
<p>修改<code>user-consumer</code>的<code>com.itheima.controller.UserController</code>的调用方式，不再手动获取ip和端口，而是直接通过服务名称调用，代码如下：</p>
<figure data-type="image" tabindex="50"><img src="images%5C1563112311866.png" alt="1563112311866" loading="lazy"></figure>
<p>(3)测试</p>
<p>启动并访问测试<code>&lt;http://localhost:18082/consumer/1&gt;</code>,可以发现，数据会在2个服务之间轮询切换。</p>
<figure data-type="image" tabindex="51"><img src="images%5C1563113049010.png" alt="1563113049010" loading="lazy"></figure>
<h5 id="5223-其他负载均衡策略配置把下面配置拷贝到消费者的配置文件即可"><mark>5.2.2.3 其他负载均衡策略配置,把下面配置拷贝到消费者的配置文件即可↓</mark></h5>
<p>配置修改轮询策略：Ribbon默认的负载均衡策略是轮询，通过如下配置可做修改,联系记忆bb,cckey,随机规则↓</p>
<pre><code class="language-yaml"># 修改服务地址轮询策略，默认是轮询，配置之后变随机↑
user-provider: #不能省要告诉我对哪个服务提供者进行负载均衡,NFLoadBalancerRuleClassName忘了搜ccckey里面找带有负载均衡规则类名,接下来赋值类,基本上你会写随机规则类或者轮询规则,但是不写配置就是轮询
  ribbon:
    #轮询
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule
    #随机算法
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule
    #重试算法,该算法先按照轮询的策略获取服务,如果获取服务失败则在指定的时间内会进行重试，获取可用的服务↓
    #可以在idea软件中按ctr shift n或者t搜对应的类进行其中一种算法涉及时间的说明↑
    #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule
    #加权法,会根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越大。刚启动时如果统计信息不足，则使用轮询的策略，等统计信息足够,才会切换到自身规则。
    NFLoadBalancerRuleClassName: com.netflix.loadbalancer.ZoneAvoidanceRule
</code></pre>
<p>SpringBoot可以修改负载均衡规则，配置为<code>ribbon.NFLoadBalancerRuleClassName</code></p>
<p>格式{服务名称}.ribbon.NFLoadBalancerRuleClassName</p>
<h4 id="523-负载均衡源码跟踪探究">5.2.3 负载均衡源码跟踪探究</h4>
<p><mark>为什么只输入了Service服务名称比如user-provider就可以访问了呢？不应该需要获取ip和端口吗？</mark></p>
<p>负载均衡器动态的从Eureka服务注册中心,获取服务提供者的访问地址(host、port)</p>
<p>显然是有某个<strong>组件</strong>根据Service服务名称，获取了服务实例ip和端口。就是<strong>组件</strong>就是<mark>LoadBalancerInterceptor</mark></p>
<p><mark>这个拦截器类会对RestTemplate的请求进行拦截，然后从Eureka根据<strong>服务id如user-provider</strong>获取服务列表，随后利用负载均衡算法得到<strong>真正服务地址</strong>信息，替换服务id如user-provider。</mark></p>
<p>源码跟踪步骤：</p>
<p>打开LoadBalancerInterceptor类(搜类用ctr shift n或者ctr shift t)，断点打入intercept方法中</p>
<figure data-type="image" tabindex="52"><img src="images%5C1563118138994.png" alt="1563118138994" loading="lazy"></figure>
<p>经过测试知道等会会来到Ribbon负载均衡客户端RibbonLoadBalancerClient类的execute方法：发现获取了18081发端口的服务(<mark>重点关注这里即可,在server处加断点,看到ip后点绿色正方体按钮<img src="assets/1603348184530.png" alt="1603348184530" loading="lazy">放行,进行下一次的测试↓</mark>)</p>
<figure data-type="image" tabindex="53"><img src="images%5C1563118256259.png" alt="1563118256259" loading="lazy"></figure>
<p>再跟下一次，发现获取的是18081和18083之间切换</p>
<figure data-type="image" tabindex="54"><img src="images%5C1563118382026.png" alt="1563118382026" loading="lazy"></figure>
<p>通过代码断点源码调试,证明了我们的前面的结论的正确</p>
<h3 id="53-小结">5.3 小结</h3>
<ul>
<li>Ribbon的<strong>负载均衡算法应用在客户端(Http请求)</strong>，只需要提供服务列表，就能帮助消费端自动访问服务端，并通过不同算法来实现客户端消费者的负载均衡。</li>
<li>Ribbon的轮询、随机算法配置：在application.yml中配置 <code>{服务名称}.ribbon.NFLoadBalancerRuleClassName</code></li>
<li>负载均衡的切换:LoadBalancerInterceptor负载均衡类获取服务的名字，通过调用RibbonLoadBalancerClient负载均衡客户端类的execute执行方法，并获取ILoadBalancer到负载均衡器，然后根据ILoadBalancer负载均衡器,查询出要使用的节点，再获取节点的信息，实现调用。</li>
</ul>
<h2 id="6-熔断器-spring-cloud-hystrix"><mark>6 熔断器 Spring Cloud Hystrix</mark></h2>
<h3 id="61-目标">6.1 目标</h3>
<ul>
<li>理解Hystrix的作用</li>
<li>理解雪崩效应</li>
<li>知道熔断器的3个状态以及3个状态的切换过程</li>
<li>能理解什么是线程隔离，什么是服务降级</li>
<li>能实现一个局部方法熔断案例</li>
<li>能实现全局方法熔断案例</li>
</ul>
<h3 id="62-讲解">6.2 讲解</h3>
<h4 id="621-hystrix-简介">6.2.1 Hystrix 简介</h4>
<figure data-type="image" tabindex="55"><img src="images%5Chystrix-logo-tagline-640.png" alt="hystrix-logo-tagline-640" loading="lazy"></figure>
<p>Hystrix，英文意思是豪猪，全身是刺，刺是一种保护机制。Hystrix也是Netflix公司的一款组件。</p>
<p><mark>Hystrix的作用是什么？：实现服务熔断降级处理，保护微服务，防止雪崩效应发生。</mark></p>
<p>Hystrix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库、防止出现<strong>级联失败</strong>也就是<strong>雪崩效应</strong>的情况发生.</p>
<h4 id="622-雪崩效应">6.2.2 雪崩效应</h4>
<p>什么是雪崩效应？</p>
<pre><code class="language-properties">1.微服务中，一个请求可能需要多个微服务接口才能实现，会形成复杂的调用链路。
2.如果某服务出现异常，请求阻塞，用户得不到响应，容器中线程不会释放，于是越来越多用户请求堆积，越来越多线程阻塞。
3.单台服务器支持线程和并发数有限，请求如果一直阻塞，会导致服务器资源耗尽，从而导致所有其他服务都不可用，从而形成雪崩效应；
</code></pre>
<p>Hystrix解决雪崩问题的手段，主要是线程隔离,服务降级**(兜底)**；</p>
<h4 id="623-熔断原理分析">6.2.3 熔断原理分析</h4>
<figure data-type="image" tabindex="56"><img src="images%5C1558425403175.png" alt="1558425403175" loading="lazy"></figure>
<p>熔断器的原理很简单，如同电力过载保护器。</p>
<p>熔断器状态机有3个状态：</p>
<pre><code class="language-properties">1.Closed：关闭状态，所有请求正常访问
2.Open：打开状态，所有请求都会被降级。
  Hystrix会对请求情况计数，当一定时间失败请求百分比达到阈(yu：四声)值(极限值)，则触发熔断，断路器完全关闭
  默认失败比例的阈值是50%，请求次数最低不少于20次
3.Half Open：半开状态
  Open状态不是永久的，打开一会后会进入休眠时间(默认5秒)。休眠时间过后会进入半开状态。
  半开状态：熔断器会判断下一次请求的返回状况，如果成功，熔断器切回closed状态。如果失败，熔断器切回open状态。
threshold reached 到达阈(yu：四声)值
under threshold  阈值以下
</code></pre>
<figure data-type="image" tabindex="57"><img src="images%5C1558064571689.png" alt="1558064571689" loading="lazy"></figure>
<p>​																		【Hystrix熔断状态机模型：配图】</p>
<p><strong>翻译之后的图：</strong></p>
<figure data-type="image" tabindex="58"><img src="images%5C1563120878233.png" alt="1563120878233" loading="lazy"></figure>
<p><strong>熔断器的核心：线程隔离和服务降级。</strong></p>
<pre><code class="language-properties">1.线程隔离：是指Hystrix为每个依赖服务调用一个小的线程池，如果线程池用尽，调用立即被拒绝，默认不采用排队。
2.服务降级(兜底方法)：优先保证核心服务，而非核心服务不可用或弱可用。触发Hystrix服务降级的情况：线程池已满、请求超时等。
</code></pre>
<p>线程隔离和服务降级之后，用户请求故障时，线程不会被阻塞，更不会无休止等待或者看到系统奔溃，至少可以看到执行结果(熔断机制)。</p>
<h4 id="624-局部熔断服务降级案例">6.2.4 局部熔断/服务降级案例</h4>
<p>目标：服务提供者的服务出现了故障，服务消费者快速失败给用户友好提示。体验服务降级</p>
<p>降级：某个方法发生故障，则返回默认的数据给用户，此时叫服务降级。</p>
<p><strong>实现步骤：</strong></p>
<p>(1)消费者,引入熔断的依赖坐标：</p>
<p>在<code>user-consumer</code>中加入依赖</p>
<pre><code class="language-xml">&lt;!--熔断器--&gt;
&lt;dependency&gt;
    &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt;
    &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt;
&lt;/dependency&gt;
</code></pre>
<p><mark>(2)开启熔断的注解</mark></p>
<p>修改<code>user-consumer</code>的<code>com.itheima.UserConsumerApplication</code>,在该类上添加<code>@EnableCircuitBreaker</code>,代码如下：</p>
<figure data-type="image" tabindex="59"><img src="images%5C1563121853130.png" alt="1563121853130" loading="lazy"></figure>
<p><mark>注意：这里也可以使用<code>@SpringCloudApplication</code>,写了<code>@SpringCloudApplication</code>后，其他注解需要全部去掉。</mark></p>
<pre><code>@SpringCloudApplication//一个顶上面三个,打开这个注解看到里面就有上面三个注解↓
</code></pre>
<figure data-type="image" tabindex="60"><img src="assets/1601927477681.png" alt="1601927477681" loading="lazy"></figure>
<p>(3)服务降级处理,说白了就是搞一个替补方法不走原来应该走的方法,因为原来方法出现了问题↓</p>
<p>在<code>user-consumer</code>的<code>com.itheima.controller.UserController</code>中添加降级处理方法，方法如下：</p>
<pre><code class="language-java">/**
 * 服务降级处理方法
 * @return
 */
public User failBack(Integer id){
    User user = new User();
    user.setUsername(&quot;服务降级,默认处理！&quot;);
    return  user;
}
</code></pre>
<p>在有可能发生问题的方法上添加降级处理调用，例如在<code>queryById</code>方法上添加降级调用，代码如下：</p>
<figure data-type="image" tabindex="61"><img src="images%5C1563122266205.png" alt="1563122266205" loading="lazy"></figure>
<p>(4)测试</p>
<p>将服务全部停掉，启动<code>eureka-server</code>和<code>user-consumer</code>,然后请求<code>&lt;http://localhost:18082/consumer/1&gt;</code>测试效果如下：</p>
<figure data-type="image" tabindex="62"><img src="images%5C1563122351298.png" alt="1563122351298" loading="lazy"></figure>
<h4 id="625-扩展-服务降级的fallback方法">6.2.5 扩展-服务降级的fallback方法：</h4>
<!--注意：因为熔断的降级逻辑方法跟正常逻辑方法一样，必须保证相同的参数列表和返回值相同-->
<p>两种编写方式：编写在类上，编写在方法上。</p>
<p>在类的上边对类的所有方法都生效。在方法上，仅对当前方法有效。</p>
<p>(1)方法上服务降级的fallback兜底方法</p>
<pre><code class="language-properties">使用HystrixCommon注解，定义
@HystrixCommand(fallbackMethod=&quot;failBack&quot;)用来声明一个降级逻辑的fallback兜底方法
</code></pre>
<p>(2)类上默认服务降级的fallback兜底方法</p>
<pre><code class="language-properties">刚才把fallback写在了某个业务方法上，如果方法很多，可以将FallBack配置加在类上，实现默认FallBack
@DefaultProperties(defaultFallback=”defaultFailBack“)，在类上，指明统一的失败降级方法；
</code></pre>
<p>(3)案例</p>
<p>a.在<code>user-consumer</code>的<code>com.itheima.controller.UserController</code>类中添加一个全局熔断方法：</p>
<pre><code class="language-java">/**
 * 全局的服务降级处理方法
 * @return
 */
public User defaultFailBack(){
    User user = new User();
    user.setUsername(&quot;Default-服务降级,默认处理！&quot;);
    return  user;
}
</code></pre>
<p>b.在<code>queryById</code>方法上将原来的<code>@HystrixCommand</code>相关去掉，并添加<code>@HystrixCommand</code>注解：</p>
<pre><code class="language-java">@HystrixCommand
@GetMapping(value = &quot;/{id}&quot;)
public User queryById(@PathVariable(value = &quot;id&quot;)Integer id){
    //...略
    return  user;
}
</code></pre>
<p>c.在<code>user-consumer</code>的<code>com.itheima.controller.UserController</code>类上添加<code>@DefaultProperties(defaultFallback = &quot;defaultFailBack&quot;)</code></p>
<p>d.测试访问<code>&lt;http://localhost:18082/consumer/1&gt;</code>，效果如下：</p>
<figure data-type="image" tabindex="63"><img src="images%5C1563127220002.png" alt="1563127220002" loading="lazy"></figure>
<p><code>com.itheima.controller.UserController</code>完整代码：</p>
<figure data-type="image" tabindex="64"><img src="images%5C1563127319873.png" alt="1563127319873" loading="lazy"></figure>
<p><strong><mark>熔断器熔断流程和3个状态讲解,理解为类似饭堂保安↓</mark></strong></p>
<figure data-type="image" tabindex="65"><img src="assets/1601957022241.png" alt="1601957022241" loading="lazy"></figure>
<h4 id="熔断器服务降级局部方法降级全局方法降级看这个总结即可简单另外再看看熔断策略配置的一些参数即可"><mark>熔断器服务降级,局部方法降级,全局方法降级看这个总结即可,简单,另外再看看熔断策略配置的一些参数即可↓</mark></h4>
<p><mark>@DefaultProperties可以不用,其实没那么复杂,用一个注解@HystrixCommand里面的两个属性来分别指定即可↓</mark></p>
<figure data-type="image" tabindex="66"><img src="assets/1601929327118.png" alt="1601929327118" loading="lazy"></figure>
<p>当然,别忘了引入hystrix熔断器依赖和用@SpringCloudApplication注解开启熔断器↓</p>
<figure data-type="image" tabindex="67"><img src="assets/1601929668683.png" alt="1601929668683" loading="lazy"></figure>
<h4 id="626-其他熔断策略配置放最后讲如果你不想配置那就保持默认值">6.2.6 其他熔断策略配置,放最后讲,如果你不想配置,那就保持默认值↓</h4>
<h4 id="熔断器命令默认配置策略配置记不住按shift键两次搜索打开hystrixcommandproperties类查看一下就知道"><mark>熔断器命令默认配置策略配置记不住?,按shift键两次搜索打开HystrixCommandProperties类查看一下就知道↓</mark></h4>
<figure data-type="image" tabindex="68"><img src="assets/1601956740950.png" alt="1601956740950" loading="lazy"></figure>
<p>消费者,搜索hystrix命令属性类,查看对应的配置熔断策略,拷贝下来修修改改即可↑↓</p>
<figure data-type="image" tabindex="69"><img src="assets/1603358255013.png" alt="1603358255013" loading="lazy"></figure>
<pre><code class="language-yaml"># 消费者,搜索hystrix命令属性类,查看对应的配置熔断策略,拷贝下来修修改改即可,注意首字母小写↓：
hystrix:
  command:
    default:
      circuitBreaker:
        # 强制打开熔断器 默认false关闭的。测试配置是否生效
        forceOpen: false
        # 触发熔断错误比例阈值，默认值50%!!!
        errorThresholdPercentage: 50
        # 熔断后休眠时长，默认值5秒,即睡眠5秒去看服务如果没有问题,熔断器由半开到关闭,恢复服务的访问
        sleepWindowInMilliseconds: 10000
        # 熔断触发最小请求次数，默认值是20,即请求访问服务,服务出现错误2次开始触发熔断全开
        requestVolumeThreshold: 2
      execution:
        isolation:
          thread:
            # 熔断降级超时设置，默认为1秒,即访问服务耗时超过1秒就服务降级
            timeoutInMilliseconds: 2000
</code></pre>
<h4 id="如果是properties文件前面都是hystrixcommanddefault后面忘了抄下面即可所以了忘了就对了"><mark>如果是properties文件,前面都是hystrix.command.default.,后面忘了抄下面即可,所以了忘了就对了↓</mark></h4>
<figure data-type="image" tabindex="70"><img src="assets/1601958115329.png" alt="1601958115329" loading="lazy"></figure>
<figure data-type="image" tabindex="71"><img src="assets/1601958436908.png" alt="1601958436908" loading="lazy"></figure>
<h4 id="测试第一个forceopen和最后两个requestvolumethresholdtimeoutinmilliseconds其他全部搞定"><mark>测试第一个forceOpen和最后两个requestVolumeThreshold,timeoutInMilliseconds,其他全部搞定↑</mark></h4>
<p>(1)超时时间测试</p>
<p>a.修改<code>user-provider</code>的<code>com.itheima.controller.UserController</code>的<code>findById</code>方法，让它休眠3秒钟。</p>
<p>b.修改<code>user-consumer</code>的application.yml，设置超时时间5秒，此时不会熔断。</p>
<figure data-type="image" tabindex="72"><img src="../../../../../45%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%A4%8D%E5%88%B6%E5%88%B0%E4%BD%A0%E7%94%B5%E8%84%91%E4%B8%8D%E8%A6%81%E5%89%AA%E5%88%87!!!/%E8%BF%9B%E9%98%B6%E9%98%B6%E6%AE%B5/%E5%9B%BD%E5%BA%86%E7%A6%8F%E5%88%A9/%E7%AC%AC51%E7%AB%A0%EF%BC%88springcloud_resttemplate_eureka_ribbon_hystrix%EF%BC%89/%E7%AC%94%E8%AE%B0/images/1563125744650.png" alt="1563125744650" loading="lazy"></figure>
<p>c.如果把超时时间改成2000，此时就会熔断。</p>
<p>(2)熔断触发最小请求次数测试</p>
<p>a.修改<code>user-provider</code>的<code>com.itheima.controller.UserController</code>,在方法中制造异常，代码如下：</p>
<figure data-type="image" tabindex="73"><img src="../../../../../45%E6%9C%9F%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%96%99%E5%A4%8D%E5%88%B6%E5%88%B0%E4%BD%A0%E7%94%B5%E8%84%91%E4%B8%8D%E8%A6%81%E5%89%AA%E5%88%87!!!/%E8%BF%9B%E9%98%B6%E9%98%B6%E6%AE%B5/%E5%9B%BD%E5%BA%86%E7%A6%8F%E5%88%A9/%E7%AC%AC51%E7%AB%A0%EF%BC%88springcloud_resttemplate_eureka_ribbon_hystrix%EF%BC%89/%E7%AC%94%E8%AE%B0/images/1563126432239.png" alt="1563126432239" loading="lazy"></figure>
<p>b.3次并发请求<code>&lt;http://localhost:18082/consumer/1&gt;</code>，会触发熔断</p>
<p>再次请求<code>&lt;http://localhost:18082/consumer/2&gt;</code>的时候，也会熔断，5秒钟会自动恢复。</p>
<p>并发请求建议使用<code>jmeter</code>工具。</p>
<h3 id="63-小结">6.3 小结</h3>
<ul>
<li>
<p>Hystrix的作用:用于隔离访问远程服务、第三方库、防止出现级联失败也就是雪崩效应。</p>
</li>
<li>
<p>理解雪崩效应:</p>
<pre><code class="language-properties">1.微服务中，一个请求可能需要多个微服务接口才能实现，会形成复杂的调用链路。
2.如果某服务出现异常，请求阻塞，用户得不到响应，容器中线程不会释放，于是越来越多用户请求堆积，越来越多线程阻塞。
3.单服务器支持线程和并发数有限，请求如果一直阻塞，会导致服务器资源耗尽，从而导致所有其他服务都不可用，从而形成雪崩效应；
</code></pre>
</li>
<li>
<p>知道熔断器的3个状态以及3个状态的切换过程</p>
<pre><code class="language-properties">1.Closed：关闭状态，所有请求正常访问
2.Open：打开状态，所有请求都会被降级。
  Hystrix会对请求情况计数，当一定时间失败请求百分比达到阈(yu：四声)值(极限值)，则触发熔断，断路器完全关闭
  默认失败比例的阈值是50%，请求次数最低不少于20次
3.Half Open：半开状态
  Open状态不是永久的，打开一会后会进入休眠时间(默认5秒)。休眠时间过后会进入半开状态。
  半开状态：熔断器会判断下一次请求的返回状况，如果成功，熔断器切回closed状态。如果失败，熔断器切回open状态。
threshold reached 到达阈(yu：四声)值
under threshold  阈值以下
</code></pre>
</li>
<li>
<p>能理解什么是线程隔离，什么是服务降级</p>
<pre><code class="language-properties">1.线程隔离：是指Hystrix为每个依赖服务调用一个小的线程池，如果线程池用尽，调用立即被拒绝，默认不采用排队。
2.服务降级(兜底方法)：优先保证核心服务，而非核心服务不可用或弱可用。触发Hystrix服务降级的情况：线程池已满、请求超时。
</code></pre>
</li>
<li>
<p>能实现一个局部方法熔断案例</p>
<pre><code class="language-properties">1.定义一个局部处理熔断的方法failBack()
2.在指定方法上使用@HystrixCommand(fallbackMethod = &quot;failBack&quot;)配置调用
</code></pre>
</li>
<li>
<p>能实现全局方法熔断案例</p>
<pre><code class="language-properties">1.定义一个全局处理熔断的方法defaultFailBack()
2.在类上使用@DefaultProperties(defaultFallback = &quot;defaultFailBack&quot;)配置调用
3.在指定方法上使用@HystrixCommand
</code></pre>
</li>
</ul>
<!-- more -->
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[java概念和环境搭建]]></title>
        <id>https://2050188619.github.io/post/java-gai-nian-he-huan-jing-da-jian/</id>
        <link href="https://2050188619.github.io/post/java-gai-nian-he-huan-jing-da-jian/">
        </link>
        <updated>2021-04-07T04:51:38.000Z</updated>
        <content type="html"><![CDATA[<ul>
<li>1.计算机组成
<blockquote>
<p>1.1硬件：<br>
输入设备，输出设备，存储设备，处理器，显卡，声卡，机箱。<br>
1.2软件：</p>
<blockquote>
<p>1.2.1系统软件：windows,linux,mac,unix,dos。<br>
1.2.2应用软件：<br>
B/S架构软件：通过浏览器访问应用软件。</p>
</blockquote>
<blockquote>
<blockquote>
<p>优点：使用方便无需安装客户端，数据安全（数据存放在服务器中），升级方便，更新只需要刷新浏览器即可。<br>
缺点：界面简陋，服务器压力大。<br>
C/S架构软件：</p>
</blockquote>
</blockquote>
<blockquote>
<blockquote>
<p>优点：服务器压力小，界面比较精美。<br>
缺点：必须安装客户端才能使用，每次更新客户端都需要跟着更新，数据安全稍低。</p>
</blockquote>
</blockquote>
</blockquote>
</li>
<li>2.程序
<blockquote>
<p>程序是为了模拟现实世界，解决现实问题而编写的一系列有序指令集合。</p>
</blockquote>
</li>
<li>3.编程开发<br>
3.1开发语言：Java</li>
</ul>
<pre><code>        3.1.1 java是一个跨平台的，面向对象的，强类型的，编译解释型语言。
        3.1.2 java优点：
            简单（有自动垃圾回收机制，有自动类型检查机制）
            跨平台（java可以在多个系统上运行）
            面向对象（贴合人类思维方式）
            安全性高（有强大的自动类型检查机制）

    3.1.3 语言执行机制
            3.1.3.1 编译执行机制：将源文件编译成平台可以识别的机器码文件，如c,c++。
            3.1.3.2 解释执行机制：将源文件交给不同平台的jvm解释执行。
            3.1.3.3 编译解释机制：先将源文件编译成字节码文件，再将字节码文件交给不同平台的jvm解释执行。（优点：跨平台）

    3.1.4 Java体系：
            JavaSE:java平台标准版，java核心语法。用作桌面应用程序。
            JavaEE:java平台企业版，java企业级开发。用作面向Internet应用程序。
            JavaME:java平台微型版，嵌入式或者手机端开发，如机顶盒和手机移动开发。
 
    3.1.5 Java应用
		    1.作面向桌面应用程序.
			2.面向internet应用程序.
			3.用来作机顶盒,或手机移动端开发.
			4.为大型企业提供解决方案.
			5.学习大数据基础.
    3.1.6 开发工具：记事本，notepad++,eclipse,myeclipse,idea。
    3.1.7 java开发工具包，其中包括jvm,jre,编译器等等。
</code></pre>
<hr>
<ul>
<li>4.Java环境搭建
<blockquote>
<p>4.1:卸载软件:控制面板-&gt;程序和功能-&gt;选择要卸载软件右键卸载-&gt;手动删除残留的文件.<br>
4.2:安装jdk步骤:</p>
<blockquote>
<p>4.2.1:安装jdk,注意选择安装目录.eg:D:jdk1.8</p>
</blockquote>
</blockquote>
<pre><code>  		- bin:存放java命令
  		- jre:java运行环境
  		- lib:存放Java所需的Jar包
  		- src.zip:存放Java源码包.

  &gt;&gt;4.2.2:安装jre,注意选择安装目录.eg:D:jdk1.8jre
  &gt;&gt;4.2.3:测试jdk是否安装好:cmd-&gt;进入dos系统-&gt;进入jdk安装目录\bin-&gt;输入命令测试
  		- java -version
  		- javac
  		- java
  &gt;&gt;4.2.4:配置Java环境:让计算机在任何地方都可以识别Java命令.
  			选中我的计算机右键属性-&gt;高级系统配置-&gt;环境变量-&gt;系统变量配置
  			JAVA_HOME:D:\jdk1.8
  			path:在path路径中开头%JAVA_HOME%\bin;
  	  部分电脑:
  			classpath:
              .;%JAVA_HOME%\lib\dt.jar;%JAVA_HOME%\lib\tools.jar
</code></pre>
</li>
</ul>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[JAVA中&&和&、||和|的区别]]></title>
        <id>https://2050188619.github.io/post/java-gai-shu/</id>
        <link href="https://2050188619.github.io/post/java-gai-shu/">
        </link>
        <updated>2021-04-06T14:16:52.000Z</updated>
        <content type="html"><![CDATA[<pre><code>if(a==1 &amp;&amp; b==2) 这是说既要满足a=1,也要满足b=2;
if(a==1 || b==2) 这是说只需要满足a=1,或者满足b=2;
</code></pre>
<p>而a &amp; b和 a | b是二进制的与或运算<br>
&amp;同为1时为1，否则为0；<br>
| 同为0时为0，否则为1；</p>
<h1 id="短路求值">短路求值</h1>
<pre><code>        int a=10,b=10;
        if((a=0)==0 || (b=20)==20){
        }
        System.out.println(b);
        if((a=0)==0 | (b=20)==20){
        }
        System.out.println(b);
</code></pre>
<p>为什么第一个输出的b没有改变，而第二个b改变了呢？<br>
正是因为短路求值的原因，在 || 之前已经为true时，那么后面将会进行短路，不再继续操作。<br>
而 | 却不会进行短路。</p>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[HelloWorld]]></title>
        <id>https://2050188619.github.io/post/di-yi-ge-jie-mian/</id>
        <link href="https://2050188619.github.io/post/di-yi-ge-jie-mian/">
        </link>
        <updated>2021-03-31T08:18:46.000Z</updated>
        <content type="html"><![CDATA[<p>首先下载jdk，安装配置好环境后，新建一个Java文件，命名为HelloWorld。<br>
win+R进入运行界面，输入cmd进入Widow命令提示符。<br>
先用cd命令进入文件所在位置，输入javac HelloWorld.java<br>
编译成功后再输入java HelloWorld即可运行程序</p>
<pre><code>public class HelloWorld{
	public static void main(String[] args){
	System.out.println(&quot;HelloWorld&quot;);
    }
}
</code></pre>
]]></content>
    </entry>
    <entry>
        <title type="html"><![CDATA[MarkDown语法快速入门]]></title>
        <id>https://2050188619.github.io/post/di-er-ge-jie-mian/</id>
        <link href="https://2050188619.github.io/post/di-er-ge-jie-mian/">
        </link>
        <updated>2021-03-31T08:12:04.000Z</updated>
        <content type="html"><![CDATA[<h2 id="1代码块">1.代码块：</h2>
<pre><code>这里是代码块展示
java
</code></pre>
<h2 id="2标题">2.标题</h2>
<pre><code># 1级标题
## 2级标题
#### 4级标题
</code></pre>
<h2 id="3字体">3.字体</h2>
<p>//加粗<br>
<strong>等不到天亮</strong><br>
//代码高亮显示<br>
<mark>我是孙红雷</mark><br>
//删除线<br>
<s>被删除的文字</s><br>
//斜体<br>
<em>斜体内容</em></p>
<h2 id="4引用">4.引用</h2>
<pre><code>&gt; 作者：
&gt;&gt; 作者：
&gt;&gt;&gt; 作者：
</code></pre>
<blockquote>
<p>作者：</p>
<blockquote>
<p>作者：</p>
<blockquote>
<p>作者：</p>
</blockquote>
</blockquote>
</blockquote>
<h2 id="5分割线">5.分割线</h2>
<pre><code>---
***
</code></pre>
<h2 id="6图片插入">6.图片插入</h2>
<pre><code>//在线图片
![]()
//本地图片
</code></pre>
<h2 id="7超链接">7.超链接</h2>
<pre><code>[]()
</code></pre>
<h2 id="8列表">8.列表</h2>
<pre><code>//无需列表
-目录1
-目录2
-目录3
</code></pre>
<h2 id="9脚注">9.脚注</h2>
<p>创建脚注如以下 <sup class="footnote-ref"><a href="#fn1" id="fnref1">[1]</a></sup></p>
<hr class="footnotes-sep">
<section class="footnotes">
<ol class="footnotes-list">
<li id="fn1" class="footnote-item"><p>学的是精华。 <a href="#fnref1" class="footnote-backref">↩︎</a></p>
</li>
</ol>
</section>
]]></content>
    </entry>
</feed>