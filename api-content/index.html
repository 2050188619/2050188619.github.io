{"posts":[{"title":"# 第1天 SpringCloud","content":"第1天 SpringCloud 学习目标 能够理解SpringCloud作用 用来做微服务架构的技术解决方案 SpringCloud基于SpringBoot开发的，SpringCloud整合了很多优秀的第三方微服务开源框架 能够使用RestTemplate发送请求 封装了基于Rest的Http请求[实现Http请求] 可以实现Java对象序列化与反序列化[序列化与反序列化] 能够搭建Eureka注册中心 用于管理服务、监控服务、服务路由 项目注册:服务提供者注册、服务消费者注册、Eureka注册中心(Zookeeper) 能够使用Ribbon负载均衡 用来实现负载均衡(实现消费方负载均衡) 能够使用Hystrix熔断器 做服务降级，防止程序发生雪崩 1 初识Spring Cloud 大家谈起的微服务，大多来讲说的只不过是种架构方式。其实现方式很多种：Spring Cloud，Dubbo，华为的Service Combo，Istio 。 那么这么多的微服务架构产品中，我们为什么要用Spring Cloud？因为它后台硬、技术强、群众基础好，使用方便； 1.1 目标 了解微服务架构 了解SpringCloud技术 1.2 讲解 1.2.1 技术架构演变 (1)单一应用架构 当网站流量很小时，只需要一个应用，所有功能部署在一起，减少部署节点成本的框架称之为集中式框架。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。 (2)垂直应用架构 当访问量逐渐增大，单一应用增加机器带来的加速度越来越小，将应用拆成互不相干的几个应用，以提升效率。此时，用于加速前端页面开发的Web框架(MVC)是关键。 (3)分布式服务架构 当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式服务框架(RPC)是关键。 (4)面向服务(SOA)架构 典型代表有两个：流动计算架构和微服务架构； 流动计算架构： 当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键。流动计算架构的最佳实践阿里的Dubbo。 微服务架构 与流动计算架构很相似，除了具备流动计算架构优势外，微服务架构中的微服务可以独立部署，独立发展。且微服务的开发不会限制于任何技术栈。微服务架构的最佳实践是SpringCloud。 1.2.2 SpringCloud简介 (1)SpringCloud介绍 Spring Boot擅长的是集成，把世界上最好的框架集成到自己项目中 Spring Cloud本身也是基于SpringBoot开发而来，SpringCloud是一系列框架的有序集合,也是把非常流行的微服务的技术整合到一起，是属于微服务架构的一站式技术解决方案。 Spring Cloud包含了： 注册中心：Eureka、consul、Zookeeper 负载均衡：Ribbon 熔断器：Hystrix 服务通信：Feign 网关：Gateway 配置中心 ：config 消息总线：Bus 集群状态等等....功能。 Spring Cloud协调分布式环境中各个微服务，为各类服务提供支持。 (2)Spring Cloud的版本 版本说明： SpringCloud是一系列框架组合，为了避免与框架版本产生混淆，采用新的版本命名方式，形式为大版本名+子版本名称 大版本名用伦敦地铁站名 子版本名称三种 SNAPSHOT：快照版本，尝鲜版，随时可能修改 M版本，MileStone，M1表示第一个里程碑版本，一般同时标注PRE，表示预览版 SR，Service Release，SR1表示第一个正式版本，同时标注GA(Generally Available)，稳定版 (3)SpringCloud与SpringBoot版本匹配关系 SpringBoot SpringCloud 1.2.x Angel版本 1.3.x Brixton版本 1.4.x Camden版本 1.5.x Dalston版本、Edgware 2.0.x Finchley版本 2.1.x Greenwich GA版本 (2019年2月发布) 鉴于SpringBoot与SpringCloud关系，SpringBoot建议采用2.1.x版本 1.3 小结 微服务架构：就是将相关的功能独立出来，单独创建一个项目，并且连数据库也独立出来，单独创建对应的数据库。本质：将相关独立的业务完全独立出来，对应的工程和数据库也完全独立出来。 Spring Cloud本身也是基于SpringBoot开发而来，SpringCloud是一系列框架的有序集合,把非常流行的微服务的技术整合到了一起。 2 服务调用方式 2.1 目标 理解RPC和HTTP的区别 能使用RestTemplate发送请求(发送Http请求) 2.2 讲解 2.2.1 RPC和HTTP 常见远程调用方式： RPC:(Remote Produce Call)远程过程调用 1.基于Socket 2.自定义数据格式 3.速度快，效率高 4.典型应用代表：Dubbo，WebService，ElasticSearch集群间互相调用 HTTP：网络传输协议 1.基于TCP/IP 2.规定数据传输格式 3.缺点是消息封装比较臃肿、传输速度比较慢 4.优点是对服务提供和调用方式没有任何技术限定，自由灵活，更符合微服务理念 RPC和HTTP的区别：RPC是根据语言API来定义，而不是根据基于网络的应用来定义。 Http客户端工具 常见Http客户端工具：HttpClient(发送Http请求)、OKHttp(发送Http请求)、URLConnection(发送Http请求)。 2.2.2 Spring的RestTemplate (1)RestTemplate介绍 RestTemplate是Rest的HTTP客户端模板工具类 对基于Http的客户端进行封装 实现对象与JSON的序列化与反序列化(JSON&lt;-&gt;JavaBean) 不限定客户端类型，目前常用的3种客户端都支持：HttpClient、OKHttp、JDK原生URLConnection(默认方式) (2)RestTemplate入门案例 我们可以使用RestTemplate实现上图中的请求，springcloud-day1-resttemplate通过发送请求，请求springcloud-day1-provider的/user/list方法。 (1)搭建springcloud-day1-provider 这里不演示详细过程了，大家直接使用IDEA搭建一个普通的SpringBoot工程即可。 坐标 &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;springcloud-day1-provider&lt;/artifactId&gt; &lt;version&gt;0.0.1-SNAPSHOT&lt;/version&gt; pom.xml依赖 &lt;!--父工程--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--web起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建com.itheima.domain.User public class User implements Serializable { private String name; private String address; private Integer age; public User() { } public User(String name, String address, Integer age) { this.name = name; this.address = address; this.age = age; } //..get set toString 略 } application.properties server.port=18081 创建com.itheima.controller.UserController,代码如下： @RestController @RequestMapping(value = &quot;/user&quot;) public class UserController { /*** * 提供服务 * @return */ @RequestMapping(value = &quot;/list&quot;) public List&lt;User&gt; list(){ List&lt;User&gt; users = new ArrayList&lt;User&gt;(); users.add(new User(&quot;王五&quot;, &quot;深圳&quot;, 25)); users.add(new User(&quot;李四&quot;, &quot;北京&quot;, 23)); users.add(new User(&quot;赵六&quot;, &quot;上海&quot;, 26)); return users; } } 创建启动类，并启动工程 @SpringBootApplication public class SpringcloudDay1ProviderApplication { public static void main(String[] args) { SpringApplication.run(SpringcloudDay1ProviderApplication.class, args); } } 访问：&lt;http://localhost:18081/user/list&gt;效果如下： (2)创建springcloud-day1-resttemplate 创建的详细过程也不讲解了，直接使用IDEA创建一个SpringBoot工程即可。 pom.xml依赖 &lt;!--父工程--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;relativePath/&gt; &lt;!-- lookup parent from repository --&gt; &lt;/parent&gt; &lt;dependencies&gt; &lt;!--web起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--测试包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; 创建启动类，并在启动类中创建RestTemplate对象 @SpringBootApplication public class SpringcloudDay1ResttemplateApplication { public static void main(String[] args) { SpringApplication.run(SpringcloudDay1ResttemplateApplication.class, args); } /*** * @Bean:创建一个对象实例，并将对象交给Spring容器管理 * &lt;bean id=&quot;restTemplate&quot; class=&quot;org.springframework.web.client.RestTemplate&quot; /&gt; * @return */ @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } } 测试 在测试类HttpDemoApplicationTests中@Autowired注入RestTemplate 通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码 RestTemplate会自动发起请求，接收响应 并且帮我们对响应结果进行反序列化 代码如下： @RunWith(SpringRunner.class) @SpringBootTest public class SpringcloudDay1ResttemplateApplicationTests { @Autowired private RestTemplate restTemplate; /** * RestTemplate远程调用 */ @Test public void testRestTemplateQuery() { String url = &quot;http://localhost:18081/user/list&quot;; String result = restTemplate.getForObject(url, String.class); System.out.println(result); } } 运行测试方法，效果如下： 2.3 小结 RPC和HTTP的区别：RPC是根据语言API来定义，而不是根据基于网络的应用来定义。 RestTemplate: ①RestTemplate是Rest的HTTP客户端模板工具类。 ②对基于Http的客户端进行封装。 ③实现对象与JSON的序列化与反序列化。 ④不限定客户端类型 RestTemplate的使用 创建一个RestTemplate，将该对象实例给SpringIOC容器管理 @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } restTemplate.getForObject(url,String.class); 3 模拟微服务业务场景 模拟开发过程中的服务间关系。抽象出来，开发中的微服务之间的关系是生产者和消费者关系。 总目标：模拟一个最简单的服务调用场景，场景中保护微服务提供者(Producer)和微服务调用者(Consumer)，方便后面学习微服务架构 注意：实际开发中，每个微服务为一个独立的SpringBoot工程。 3.1 目标 创建父工程 搭建服务提供者 搭建服务消费者 服务消费者使用RestTemplate调用服务提供者 3.2 讲解 3.2.1 创建父工程 (1)新建工程 新建一个Maven父工程springcloud-parent,创建步骤如下： （2）引入依赖 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt; &lt;packaging&gt;pom&lt;/packaging&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;modules&gt; &lt;module&gt;user-provider&lt;/module&gt; &lt;module&gt;user-consumer&lt;/module&gt; &lt;/modules&gt; &lt;!--父工程--&gt; &lt;parent&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-parent&lt;/artifactId&gt; &lt;version&gt;2.1.6.RELEASE&lt;/version&gt; &lt;/parent&gt; &lt;!--SpringCloud包依赖管理--&gt; &lt;dependencyManagement&gt; &lt;dependencies&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-dependencies&lt;/artifactId&gt; &lt;version&gt;Greenwich.SR1&lt;/version&gt; &lt;type&gt;pom&lt;/type&gt; &lt;scope&gt;import&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/dependencyManagement&gt; &lt;/project&gt; 3.2.2 创建服务提供者(producer)工程 每个微服务工程都是独立的工程，连数据库都是独立的，所以我们一会要单独为该服务工程创建数据库。 工程创建步骤： 1.准备表结构 2.创建工程 3.引入依赖 4.创建Pojo，需要配置JPA的注解 5.创建Dao，需要继承JpaRepository&lt;T,ID&gt; 6.创建Service，并调用Dao 7.创建Controller，并调用Service 8.创建application.yml文件 9.创建启动类 10.测试 (1)建表 producer工程是一个独立的微服务，一般拥有独立的controller、service、dao、数据库，我们在springcloud数据库新建表结构信息，如下： -- 使用springcloud数据库 USE springcloud; -- ---------------------------- -- Table structure for tb_user -- ---------------------------- CREATE TABLE `tb_user` ( `id` int(11) NOT NULL AUTO_INCREMENT, `username` varchar(100) DEFAULT NULL COMMENT '用户名', `password` varchar(100) DEFAULT NULL COMMENT '密码', `name` varchar(100) DEFAULT NULL COMMENT '姓名', `age` int(11) DEFAULT NULL COMMENT '年龄', `sex` int(11) DEFAULT NULL COMMENT '性别，1男，2女', `birthday` date DEFAULT NULL COMMENT '出生日期', `created` date DEFAULT NULL COMMENT '创建时间', `updated` date DEFAULT NULL COMMENT '更新时间', `note` varchar(1000) DEFAULT NULL COMMENT '备注', PRIMARY KEY (`id`) ) ENGINE=InnoDB AUTO_INCREMENT=2 DEFAULT CHARSET=utf8 COMMENT='用户信息表'; -- ---------------------------- -- Records of tb_user -- ---------------------------- INSERT INTO `tb_user` VALUES ('1', 'zhangsan', '123456', '张三', '13', '1', '2006-08-01', '2019-05-16', '2019-05-16', '张三'); INSERT INTO `tb_user` VALUES ('2', 'lisi', '123456', '李四', '13', '1', '2006-08-01', '2019-05-16', '2019-05-16', '李四'); (2)新建user-provider工程 选中springcloud-parent工程-&gt;New Modul-&gt;Maven-&gt;输入坐标名字，如下步骤： 引入pom.xml依赖 &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;user-provider&lt;/artifactId&gt; &lt;!--依赖包--&gt; &lt;dependencies&gt; &lt;!--JPA包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-data-jpa&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--web起步包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;!--MySQL驱动包--&gt; &lt;dependency&gt; &lt;groupId&gt;mysql&lt;/groupId&gt; &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt; &lt;scope&gt;runtime&lt;/scope&gt; &lt;/dependency&gt; &lt;!--测试包--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-test&lt;/artifactId&gt; &lt;scope&gt;test&lt;/scope&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; (3)User对象创建 创建com.itheima.domain.User，代码如下： @Entity @Table(name = &quot;tb_user&quot;) public class User implements Serializable{ @Id @GeneratedValue(strategy = GenerationType.IDENTITY) private Integer id;//主键id private String username;//用户名 private String password;//密码 private String name;//姓名 private Integer age;//年龄 private Integer sex;//性别 1男性，2女性 private Date birthday; //出生日期 private Date created; //创建时间 private Date updated; //更新时间 private String note;//备注 //..set get toString 略 } (4)dao 创建com.itheima.dao.UserDao，代码如下： public interface UserDao extends JpaRepository&lt;User,Integer&gt; { } (5)Service层 创建com.itheima.service.UserService接口，代码如下： public interface UserService { /*** * 根据ID查询用户信息 * @param id * @return */ User findByUserId(Integer id); } 创建com.itheima.service.impl.UserServiceImpl代码如下： @Service public class UserServiceImpl implements UserService { @Autowired private UserDao userDao; /*** * 根据ID查询用户信息 * @param id * @return */ @Override public User findByUserId(Integer id) { return userDao.findById(id).get(); } } (6)控制层 创建com.itheima.controller.UserController，代码如下： @RestController @RequestMapping(value = &quot;/user&quot;) public class UserController { @Autowired private UserService userService; /*** * 根据ID查询用户信息 * @param id * @return */ @RequestMapping(value = &quot;/find/{id}&quot;) public User findById(@PathVariable(value = &quot;id&quot;) Integer id){ return userService.findByUserId(id); } } (7)application.yml配置 server: port: 18081 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root url: jdbc:mysql://127.0.0.1:3306/springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC (8)启动类创建 创建com.itheima.UserProviderApplication启动类，并启动 @SpringBootApplication public class UserProviderApplication { public static void main(String[] args) { SpringApplication.run(UserProviderApplication.class,args); } } 测试：&lt;http://localhost:18081/user/find/2&gt; 3.2.3 创建服务消费者(consumer)工程 在该工程中使用RestTemplate来调用user-provider微服务。 实现步骤： 1.创建工程 2.引入依赖 3.创建Pojo 4.创建启动类，同时创建RestTemplate对象，并交给SpringIOC容器管理 5.创建application.yml文件，指定端口 6.编写Controller，在Controller中通过RestTemplate调用user-provider的服务 7.启动测试 (1)工程搭建 选中springcloud-parent工程-&gt;New Modul-&gt;Maven-&gt;输入坐标名字，如下步骤： pom.xml依赖如下： &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;user-consumer&lt;/artifactId&gt; &lt;!--依赖包--&gt; &lt;dependencies&gt; &lt;!--web起步依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt; &lt;artifactId&gt;spring-boot-starter-web&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; (2)创建User对象 在src下创建com.itheima.domain.User,代码如下： public class User implements Serializable{ private Integer id;//主键id private String username;//用户名 private String password;//密码 private String name;//姓名 private Integer age;//年龄 private Integer sex;//性别 1男性，2女性 private Date birthday; //出生日期 private Date created; //创建时间 private Date updated; //更新时间 private String note;//备注 //..set、get、toString 略 } (3)创建启动引导类 在src下创建com.itheima.UserConsumerApplication,代码如下： @SpringBootApplication public class UserConsumerApplication { public static void main(String[] args) { SpringApplication.run(UserConsumerApplication.class,args); } /*** * 将RestTemplate的实例放到Spring容器中 * @return */ @Bean public RestTemplate restTemplate(){ return new RestTemplate(); } } 创建application.yml,并配置端口为18082 server: port: 18082 (4)创建控制层，在控制层中调用user-provider 在src下创建com.itheima.controller.UserController，代码如下： @RestController @RequestMapping(value = &quot;/consumer&quot;) public class UserController { @Autowired private RestTemplate restTemplate; /** * 在user-consumer服务中通过RestTemplate调用user-provider服务 * @param id * @return */ @GetMapping(value = &quot;/{id}&quot;) public User queryById(@PathVariable(value = &quot;id&quot;)Integer id){ String url = &quot;http://localhost:18081/user/find/&quot;+id; return restTemplate.getForObject(url,User.class); } } 启动测试： 请求地址：&lt;http://localhost:18082/consumer/1&gt; 3.2.4 思考问题 user-provider：对外提供用户查询接口 user-consumer：通过RestTemplate访问接口查询用户数据 存在的问题： 在服务消费者中，我们把url地址硬编码到代码中，不方便后期维护 在服务消费者中，不清楚服务提供者的状态(user-provider有可能没有,或者说宕机了) 服务提供者只有一个服务，即便服务提供者形成集群，服务消费者还需要自己实现负载均衡 服务提供者如果出现故障，是否能够及时发现： 其实上面说的问题，概括一下就是微服务架构必然要面临的问题 服务管理：自动注册与发现、状态监管 服务负载均衡 等等 3.3 小结 服务消费者使用RestTemplate调用服务提供者,使用RestTemplate调用的时候，需要先创建并注入到SpringIOC容器中 在服务消费者中，我们把url地址硬编码到代码中，不方便后期维护 在服务消费者中，不清楚服务提供者的状态(user-provider有可能没有,或者宕机了) 服务提供者只有一个服务，即便服务提供者形成集群，服务消费者还需要自己实现负载均衡 服务提供者的如果出现故障，不能及时发现。 4 注册中心 Spring Cloud Eureka 前面我们学过Dubbo，关于Dubbo的执行过程我们看如下图片： 执行过程： 1.Provider:服务提供者,异步将自身信息注册到Register（注册中心） 2.Consumer：服务消费者，异步去Register中拉取服务数据 3.Register异步推送服务数据给Consumer,如果有新的服务注册了，Consumer可以直接监控到新的服务 4.Consumer同步调用Provider 5.Consumer和Provider异步将调用频率信息发给Monitor监控 4.1 目标 理解Eureka的原理图-服务注册与发现中心 能实现Eureka服务的搭建 能实现服务提供者向Eureka注册服务 能实现服务消费者向Eureka注册服务 能实现消费者通过Eureka访问服务提供者 能掌握Eureka的详细配置 4.2 讲解 4.2.1 Eureka 简介 Eureka解决了第一个问题(作用)：服务的管理，注册和发现、状态监管、动态路由。 Eureka负责管理记录服务提供者的信息。服务调用者(消费者)无需自己寻找服务，Eureka自动匹配服务给调用者。 Eureka与服务之间通过心跳机制进行监控； 4.2.2 原理图 基本架构图 Eureka：就是服务注册中心(可以是一个集群)，对外暴露自己的地址 服务提供者：启动后向Eureka注册自己的信息(地址，提供什么服务) 服务消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 4.2.3 入门案例 目标：搭建Eureka Server环境，创建一个eureka_server工程。 **步骤：**分三步 1：eureka-serve搭建工程eureka-server 2：服务提供者-注册服务，user-provider工程 3：服务消费者-发现服务，user-consumer工程 4.2.3.1 搭建eureka-server工程 (1)工程搭建 选中springcloud-parent工程-&gt;New Modul-&gt;Maven-&gt;输入坐标名字，如下步骤： (2)pom.xml引入依赖,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓ &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt; &lt;project xmlns=&quot;http://maven.apache.org/POM/4.0.0&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot; xsi:schemaLocation=&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;&gt; &lt;parent&gt; &lt;artifactId&gt;springcloud-parent&lt;/artifactId&gt; &lt;groupId&gt;com.itheima&lt;/groupId&gt; &lt;version&gt;1.0-SNAPSHOT&lt;/version&gt; &lt;/parent&gt; &lt;modelVersion&gt;4.0.0&lt;/modelVersion&gt; &lt;artifactId&gt;eureka-server&lt;/artifactId&gt; &lt;!--依赖包,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓--&gt; &lt;dependencies&gt; &lt;!--eureka-server依赖--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-server&lt;/artifactId&gt; &lt;/dependency&gt; &lt;/dependencies&gt; &lt;/project&gt; (3)application.yml配置,打个url提示,然后点击service-url跑到一个类指定它是map,给它赋值键和值即可↓ server: port: 7001 #端口号 spring: application: name: eureka-server # 应用名称，会在Eureka中作为服务的id标识（serviceId） eureka: client: register-with-eureka: false #是否将自己注册到Eureka中 fetch-registry: false #是否从eureka中获取服务信息 service-url: defaultZone: http://localhost:7001/eureka # EurekaServer的地址 (4)启动类创建 在src下创建com.itheima.EurekaServerApplication,在类上需要添加一个注解@EnableEurekaServer，用于开启Eureka服务,代码如下： @SpringBootApplication @EnableEurekaServer //开启Eureka服务 public class EurekaServerApplication { public static void main(String[] args) { SpringApplication.run(EurekaServerApplication.class,args); } } (5)启动访问 启动后，访问&lt;http://127.0.0.1:7001/&gt;，效果如下： 4.2.3.2 服务提供者-注册服务 我们的user-provider属于服务提供者，需要在user-provider工程中引入Eureka客户端依赖，然后在配置文件中指定Eureka服务地址,然后在启动类中开启Eureka服务发现功能(开启Eureka客户端功能)。 步骤： 1.引入eureka客户端依赖包 2.在application.yml中配置Eureka服务地址 3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient (1)引入依赖 在user-provider的pom.xml中引入如下依赖,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓ &lt;!--eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; (2)配置Eureka服务地址 修改user-provider的application.yml配置文件，添加Eureka服务地址，代码如下： 上图代码如下：客户端配置抄服务器的,去掉注册和抓取配置,然后修改端口和应用名即可↓ server: port: 18081 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver username: root password: root url: jdbc:mysql://127.0.0.1:3306/springcloud?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=UTC application: name: user-provider #服务的名字,不同的应用，名字不同，如果是集群，名字需要相同 #指定eureka服务地址 eureka: client: service-url: # EurekaServer的地址 defaultZone: http://localhost:7001/eureka (3)开启Eureka客户端发现功能 在user-provider的启动类com.itheima.UserProviderApplication上添加@EnableDiscoveryClient注解或者@EnableEurekaClient，用于开启客户端发现功能。 @SpringBootApplication //@EnableDiscoveryClient//开启Eureka客户端发现功能 @EnableEurekaClient //开启Eureka客户端发现功能，注册中心只能是Eureka public class UserProviderApplication { public static void main(String[] args) { SpringApplication.run(UserProviderApplication.class,args); } } 区别： @EnableDiscoveryClient和@EnableEurekaClient都用于开启客户端的发现功能，但@EnableEurekaClient的注册中心只能是Eureka。 (4)启动测试 启动eureka-server，再启动user-provider。 访问Eureka地址&lt;http://127.0.0.1:7001/&gt;，效果如下： 4.2.3.3 服务消费者-注册服务中心 消费方添加Eureka服务注册和生产方配置流程一致。 步骤： 1.引入eureka客户端依赖包 2.在application.yml中配置Eureka服务地址 3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient (1)pom.xml引入依赖 修改user-consumer的pom.xml引入如下依赖,打个eureka提示即可,提示消失太快,可以按alt /重复提示↓ &lt;!--eureka客户端--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-eureka-client&lt;/artifactId&gt; &lt;/dependency&gt; (2)application.yml中配置eureka服务地址 修改user-consumer工程的application.yml配置，添加eureka服务地址，配置如下： 上图配置如下：客户端配置抄服务器的,去掉注册和抓取配置,然后修改端口和应用名即可↓ server: port: 18082 spring: application: name: user-consumer #服务名字 #指定eureka服务地址 eureka: client: service-url: # EurekaServer的地址 defaultZone: http://localhost:7001/eureka (3)在启动类上开启Eureka服务发现功能 修改user-consumer的com.itheima.UserConsumerApplication启动类，在类上添加@EnableDiscoveryClient注解，代码如下： 上图代码如下： @SpringBootApplication @EnableDiscoveryClient //开启Eureka客户端发现功能 public class UserConsumerApplication { public static void main(String[] args) { SpringApplication.run(UserConsumerApplication.class,args); } } (4)测试 启动user-consumer，然后访问Eureka服务地址&lt;http://127.0.0.1:7001/&gt;效果如下： 4.2.3.4 消费者作为客户端通过Eureka服务器拿到提供者注册的数据即ip和端口等,去访问服务提供者 之前消费者user-consumer访问服务提供者user-provider是通过http://localhost:18081/user/find/1访问的，这里是具体的路径，没有从Eureka获取访问地址，我们可以让消费者从Eureka那里获取服务提供者的访问地址，然后访问服务提供者。 修改user-consumer的com.itheima.controller.UserController，代码如下： Debug跟踪运行，访问&lt;http://localhost:18082/consumer/1&gt;，效果如下： 跟踪运行后，我们发现，这里的地址就是服务注册中的状态名字↓ 浏览器结果如下： (2)使用IP访问配置 上面的请求地址是服务状态名字，其实也是当前被访问主机的名字，可以通过配置文件，将它换成IP，修改提供者的application.yml配置文件，代码如下： 上图配置如下：打个ip提示即可↓ instance: #指定IP地址 ip-address: 127.0.0.1 #访问服务的时候，推荐使用IP prefer-ip-address: true 重新启动user-provider，有时候消费者有缓存,所以消费者也要重启!然后通过消费者再次访问，测试效果如下： 通过上面的测试,说明restTemplate确实能通过应用服务名user-provider来得到服务器上的提供者的ip和端口,如果你给我加上加载平衡注解,那么我就自动做了! 4.2.4 Eureka详解 4.2.4.1 基础架构 Eureka架构中的三个核心角色 1.服务注册中心：Eureka服务端应用，提供服务注册发现功能，eureka-server 2.服务提供者：提供服务的应用 要求统一对外提供Rest风格的服务即可 本例子：user-provider 3.服务消费者：从注册中心获取服务列表，知道去哪调用服务提供者，user-consumer 4.2.4.2 Eureka客户端 服务提供者要向EurekaServer注册服务，并完成服务续约等工作 服务注册: 1. 当我们开启了客户端发现注解@DiscoveryClient。同时导入了eureka-client依赖坐标 2. 同时配置Eureka服务注册中心地址在配置文件中 3. 服务在启动时，检测是否有@DiscoveryClient注解和配置信息 4. 如果有，则会向注册中心发起注册请求，携带服务元数据信息(IP、端口等)到注册中心 5. Eureka注册中心会把服务的信息保存在它的Map中(万能map)。 服务续约： 服务注册完成以后，服务提供者会维持一个心跳，保证服务处于存在状态。这个称之为服务提供者续约(renew)。 上图配置如下：打个lease提示即可↓ eureka: client: service-url: # EurekaServer的地址 defaultZone: http://localhost:7001/eureka instance: #指定IP地址 ip-address: 127.0.0.1 #访问服务的时候，推荐使用IP prefer-ip-address: true #租约到期，服务时效时间，默认值90秒 lease-expiration-duration-in-seconds: 15 #租约续约间隔时间，默认30秒 lease-renewal-interval-in-seconds: 40 **获取服务列表：**注册抓取间隔时间配置,了解 上图配置如下：打个registry或者fetch提示即可↓ registry-fetch-interval-seconds: 30 说明： 服务消费者启动时，会检测是否获取到服务注册信息配置 如果是，则会从 EurekaServer获取服务列表只读备份，缓存到消费者本地 每隔30秒，会重新获取并更新数据 每隔30秒的时间可以通过配置registry-fetch-interval-seconds修改 4.2.4.3 失效剔除和自我保护 服务下线： 当服务正常关闭时，会发送服务下线的REST请求给EurekaServer。 服务中心接受到请求后，将该服务置为下线状态 失效剔除： 服务注册中心,每隔一段时间(默认60秒)将列表清单中没有续约的服务剔除。 通过eviction-interval-timer-in-ms配置可以对其进行修改，单位是毫秒 剔除时间配置 上图代码如下：自我保护和剔除时间,打个se提示即可↓ eureka: client: register-with-eureka: false #是否将自己注册到Eureka中 fetch-registry: false #是否从eureka中获取服务信息 service-url: defaultZone: http://localhost:7001/eureka # EurekaServer的地址 server: enable-self-preservation: false eviction-interval-timer-in-ms: 5000 自我保护： Eureka会统计服务提供者实例,最近15分钟心跳续约的比例是否低于85%，如果低于则会触发自我保护机制。 服务中心页面会显示如下提示信息(很容易理解,正常情况下,你服务提供者每隔30秒续约,但是你的比例太低说明你可能遇到了其他不可控的因素,比如网络问题,那我注册中心肯定不会把你的数据剔除,开启自我保护) 含义：紧急情况！Eureka可能错误地声称实例已经启动，而事实并非如此。续约低于阈值(yu)，因此实例不会为了安全而过期。 1.自我保护模式下，不会剔除任何服务实例 2.自我保护模式保证了大多数服务依然可用(比如为了应对服务提供者网络突然中断的问题等) 3.通过enable-self-preservation配置可用关停自我保护，默认值是打开的 关闭自我保护 上图配置如下,即Eureka服务器关闭自我保护机制： server: enable-self-preservation: false 4.3 小结 理解Eureka的原理图: Eureka：就是服务注册中心(可以是一个集群)，对外暴露自己的地址 服务提供者：启动后向Eureka注册自己的信息(地址，提供什么服务) 服务消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新 心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态 能实现Eureka服务的搭建:引入依赖包，配置配置文件，在启动类上加@EnableEurekaServer。 能实现服务提供者向Eureka注册服务 1.引入eureka客户端依赖包 2.在application.yml中配置Eureka服务地址 3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient 能实现服务消费者向Eureka注册服务 1.引入eureka客户端依赖包 2.在application.yml中配置Eureka服务地址 3.在启动类上添加@EnableDiscoveryClient或者@EnableEurekaClient 能实现消费者通过Eureka访问服务提供者 最重要的是配置小结,关于配置,一般都在服务提供者,有两个节点,client节点配置客户端信息比如url,instance实例节点配置服务相关信息,这个节点配置比较多比如ip或者lease,如下所示:↓ server: port: 18081 spring: datasource: driver-class-name: com.mysql.cj.jdbc.Driver url: jdbc:mysql://localhost:3306/test?useUnicode=true&amp;characterEncoding=utf-8&amp;serverTimezone=UTC username: root password: root application: name: user-provider eureka: client: service-url: defaultZone: http://localhost:7001/eureka/ registry-fetch-interval-seconds: 30 instance: prefer-ip-address: true # ip-address: localhost ip-address: 127.0.0.1 lease-expiration-duration-in-seconds: 9 lease-renewal-interval-in-seconds: 30 另外服务注册中心还多了一个server服务节点,一般用来配置关闭自我保护和剔除时间,如下:↓ server: port: 7001 #端口号 spring: application: name: eureka-server # 应用名称，会在Eureka中作为服务的id标识（serviceId） eureka: client: register-with-eureka: false #是否将自己注册到Eureka中 fetch-registry: false #是否从eureka中获取服务信息 service-url: defaultZone: http://localhost:7001/eureka server: enable-self-preservation: false eviction-interval-timer-in-ms: 5000 # EurekaServer的地址 到这里有些同学就有想法了,难道消费者不用配置其他东西了嘛?那你错了,接下来的客户端负载均衡,服务降级都是消费者方面的配置!咱们拭目以待↓ 5 负载均衡 Spring Cloud Ribbon Ribbon主要 解决如多个服务提供者,集群服务中，多个服务高效率访问的问题。 5.1 目标 理解Ribbon的负载均衡应用场景 能实现Ribbon的轮询、随机算法配置 理解源码对负载均衡的切换 5.2 讲解 5.2.1 Ribbon 简介 什么是Ribbon？ Ribbon是Netflix发布的负载均衡器，有助于控制HTTP客户端行为。为Ribbon配置服务提供者地址列表后，Ribbon就可基于负载均衡算法，自动帮助服务消费者请求。 Ribbon默认提供的负载均衡算法：轮询(默认)，随机,重试法,加权。当然，我们可用自己定义负载均衡算法 5.2.2 入门案例 5.2.2.1 多个服务集群 如果想要做负载均衡，我们的服务至少2个以上,为了演示负载均衡案例，我们可以复制2个工程，分别为user-provider和user-provider-demo1，可以按照如下步骤拷贝工程： ①选中user-provider,按Ctrl+C，然后Ctrl+V ②名字改成user-provider-demo1,点击OK ③将user-provider-demo1的artifactId换成user-provider-demo1 ④在springcloud-parent的pom.xml中添加一个&lt;module&gt;user-provider-demo1&lt;/module&gt; ⑤将user-provider-demo1的application.yml中的端口改成18083 为了方便测试，将2个工程对应的com.itheima.controller.UserController都修改一下： user-provider: @RequestMapping(value = &quot;/find/{id}&quot;) public User findById(@PathVariable(value = &quot;id&quot;) Integer id){ User user = userService.findByUserId(id); user.setUsername(user+&quot; user-provider&quot;); return user; } user-provider-demo1: @RequestMapping(value = &quot;/find/{id}&quot;) public User findById(@PathVariable(value = &quot;id&quot;) Integer id){ User user = userService.findByUserId(id); user.setUsername(user+&quot; user-provider-demo1&quot;); return user; } ⑥启动eureka-server和user-provider、user-provider-demo1、user-consumer，启动前先注释掉eureka-server中的自我保护和剔除服务配置。 访问eureka-server地址&lt;http://127.0.0.1:7001/&gt;效果如下： 5.2.2.2 开启负载均衡 (1)客户端开启负载均衡 Eureka已经集成Ribbon，所以无需引入依赖,要想使用Ribbon，直接在RestTemplate的配置方法上添加@LoadBalanced注解即可 修改user-consumer的com.itheima.UserConsumerApplication启动类，在restTemplate()方法上添加@LoadBalanced注解，代码如下： (2)采用服务提供者服务名访问配置 修改user-consumer的com.itheima.controller.UserController的调用方式，不再手动获取ip和端口，而是直接通过服务名称调用，代码如下： (3)测试 启动并访问测试&lt;http://localhost:18082/consumer/1&gt;,可以发现，数据会在2个服务之间轮询切换。 5.2.2.3 其他负载均衡策略配置,把下面配置拷贝到消费者的配置文件即可↓ 配置修改轮询策略：Ribbon默认的负载均衡策略是轮询，通过如下配置可做修改,联系记忆bb,cckey,随机规则↓ # 修改服务地址轮询策略，默认是轮询，配置之后变随机↑ user-provider: #不能省要告诉我对哪个服务提供者进行负载均衡,NFLoadBalancerRuleClassName忘了搜ccckey里面找带有负载均衡规则类名,接下来赋值类,基本上你会写随机规则类或者轮询规则,但是不写配置就是轮询 ribbon: #轮询 #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RoundRobinRule #随机算法 #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RandomRule #重试算法,该算法先按照轮询的策略获取服务,如果获取服务失败则在指定的时间内会进行重试，获取可用的服务↓ #可以在idea软件中按ctr shift n或者t搜对应的类进行其中一种算法涉及时间的说明↑ #NFLoadBalancerRuleClassName: com.netflix.loadbalancer.RetryRule #加权法,会根据平均响应时间计算所有服务的权重，响应时间越快服务权重越大被选中的概率越大。刚启动时如果统计信息不足，则使用轮询的策略，等统计信息足够,才会切换到自身规则。 NFLoadBalancerRuleClassName: com.netflix.loadbalancer.ZoneAvoidanceRule SpringBoot可以修改负载均衡规则，配置为ribbon.NFLoadBalancerRuleClassName 格式{服务名称}.ribbon.NFLoadBalancerRuleClassName 5.2.3 负载均衡源码跟踪探究 为什么只输入了Service服务名称比如user-provider就可以访问了呢？不应该需要获取ip和端口吗？ 负载均衡器动态的从Eureka服务注册中心,获取服务提供者的访问地址(host、port) 显然是有某个组件根据Service服务名称，获取了服务实例ip和端口。就是组件就是LoadBalancerInterceptor 这个拦截器类会对RestTemplate的请求进行拦截，然后从Eureka根据服务id如user-provider获取服务列表，随后利用负载均衡算法得到真正服务地址信息，替换服务id如user-provider。 源码跟踪步骤： 打开LoadBalancerInterceptor类(搜类用ctr shift n或者ctr shift t)，断点打入intercept方法中 经过测试知道等会会来到Ribbon负载均衡客户端RibbonLoadBalancerClient类的execute方法：发现获取了18081发端口的服务(重点关注这里即可,在server处加断点,看到ip后点绿色正方体按钮放行,进行下一次的测试↓) 再跟下一次，发现获取的是18081和18083之间切换 通过代码断点源码调试,证明了我们的前面的结论的正确 5.3 小结 Ribbon的负载均衡算法应用在客户端(Http请求)，只需要提供服务列表，就能帮助消费端自动访问服务端，并通过不同算法来实现客户端消费者的负载均衡。 Ribbon的轮询、随机算法配置：在application.yml中配置 {服务名称}.ribbon.NFLoadBalancerRuleClassName 负载均衡的切换:LoadBalancerInterceptor负载均衡类获取服务的名字，通过调用RibbonLoadBalancerClient负载均衡客户端类的execute执行方法，并获取ILoadBalancer到负载均衡器，然后根据ILoadBalancer负载均衡器,查询出要使用的节点，再获取节点的信息，实现调用。 6 熔断器 Spring Cloud Hystrix 6.1 目标 理解Hystrix的作用 理解雪崩效应 知道熔断器的3个状态以及3个状态的切换过程 能理解什么是线程隔离，什么是服务降级 能实现一个局部方法熔断案例 能实现全局方法熔断案例 6.2 讲解 6.2.1 Hystrix 简介 Hystrix，英文意思是豪猪，全身是刺，刺是一种保护机制。Hystrix也是Netflix公司的一款组件。 Hystrix的作用是什么？：实现服务熔断降级处理，保护微服务，防止雪崩效应发生。 Hystrix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库、防止出现级联失败也就是雪崩效应的情况发生. 6.2.2 雪崩效应 什么是雪崩效应？ 1.微服务中，一个请求可能需要多个微服务接口才能实现，会形成复杂的调用链路。 2.如果某服务出现异常，请求阻塞，用户得不到响应，容器中线程不会释放，于是越来越多用户请求堆积，越来越多线程阻塞。 3.单台服务器支持线程和并发数有限，请求如果一直阻塞，会导致服务器资源耗尽，从而导致所有其他服务都不可用，从而形成雪崩效应； Hystrix解决雪崩问题的手段，主要是线程隔离,服务降级**(兜底)**； 6.2.3 熔断原理分析 熔断器的原理很简单，如同电力过载保护器。 熔断器状态机有3个状态： 1.Closed：关闭状态，所有请求正常访问 2.Open：打开状态，所有请求都会被降级。 Hystrix会对请求情况计数，当一定时间失败请求百分比达到阈(yu：四声)值(极限值)，则触发熔断，断路器完全关闭 默认失败比例的阈值是50%，请求次数最低不少于20次 3.Half Open：半开状态 Open状态不是永久的，打开一会后会进入休眠时间(默认5秒)。休眠时间过后会进入半开状态。 半开状态：熔断器会判断下一次请求的返回状况，如果成功，熔断器切回closed状态。如果失败，熔断器切回open状态。 threshold reached 到达阈(yu：四声)值 under threshold 阈值以下 ​ 【Hystrix熔断状态机模型：配图】 翻译之后的图： 熔断器的核心：线程隔离和服务降级。 1.线程隔离：是指Hystrix为每个依赖服务调用一个小的线程池，如果线程池用尽，调用立即被拒绝，默认不采用排队。 2.服务降级(兜底方法)：优先保证核心服务，而非核心服务不可用或弱可用。触发Hystrix服务降级的情况：线程池已满、请求超时等。 线程隔离和服务降级之后，用户请求故障时，线程不会被阻塞，更不会无休止等待或者看到系统奔溃，至少可以看到执行结果(熔断机制)。 6.2.4 局部熔断/服务降级案例 目标：服务提供者的服务出现了故障，服务消费者快速失败给用户友好提示。体验服务降级 降级：某个方法发生故障，则返回默认的数据给用户，此时叫服务降级。 实现步骤： (1)消费者,引入熔断的依赖坐标： 在user-consumer中加入依赖 &lt;!--熔断器--&gt; &lt;dependency&gt; &lt;groupId&gt;org.springframework.cloud&lt;/groupId&gt; &lt;artifactId&gt;spring-cloud-starter-netflix-hystrix&lt;/artifactId&gt; &lt;/dependency&gt; (2)开启熔断的注解 修改user-consumer的com.itheima.UserConsumerApplication,在该类上添加@EnableCircuitBreaker,代码如下： 注意：这里也可以使用@SpringCloudApplication,写了@SpringCloudApplication后，其他注解需要全部去掉。 @SpringCloudApplication//一个顶上面三个,打开这个注解看到里面就有上面三个注解↓ (3)服务降级处理,说白了就是搞一个替补方法不走原来应该走的方法,因为原来方法出现了问题↓ 在user-consumer的com.itheima.controller.UserController中添加降级处理方法，方法如下： /** * 服务降级处理方法 * @return */ public User failBack(Integer id){ User user = new User(); user.setUsername(&quot;服务降级,默认处理！&quot;); return user; } 在有可能发生问题的方法上添加降级处理调用，例如在queryById方法上添加降级调用，代码如下： (4)测试 将服务全部停掉，启动eureka-server和user-consumer,然后请求&lt;http://localhost:18082/consumer/1&gt;测试效果如下： 6.2.5 扩展-服务降级的fallback方法： 两种编写方式：编写在类上，编写在方法上。 在类的上边对类的所有方法都生效。在方法上，仅对当前方法有效。 (1)方法上服务降级的fallback兜底方法 使用HystrixCommon注解，定义 @HystrixCommand(fallbackMethod=&quot;failBack&quot;)用来声明一个降级逻辑的fallback兜底方法 (2)类上默认服务降级的fallback兜底方法 刚才把fallback写在了某个业务方法上，如果方法很多，可以将FallBack配置加在类上，实现默认FallBack @DefaultProperties(defaultFallback=”defaultFailBack“)，在类上，指明统一的失败降级方法； (3)案例 a.在user-consumer的com.itheima.controller.UserController类中添加一个全局熔断方法： /** * 全局的服务降级处理方法 * @return */ public User defaultFailBack(){ User user = new User(); user.setUsername(&quot;Default-服务降级,默认处理！&quot;); return user; } b.在queryById方法上将原来的@HystrixCommand相关去掉，并添加@HystrixCommand注解： @HystrixCommand @GetMapping(value = &quot;/{id}&quot;) public User queryById(@PathVariable(value = &quot;id&quot;)Integer id){ //...略 return user; } c.在user-consumer的com.itheima.controller.UserController类上添加@DefaultProperties(defaultFallback = &quot;defaultFailBack&quot;) d.测试访问&lt;http://localhost:18082/consumer/1&gt;，效果如下： com.itheima.controller.UserController完整代码： 熔断器熔断流程和3个状态讲解,理解为类似饭堂保安↓ 熔断器服务降级,局部方法降级,全局方法降级看这个总结即可,简单,另外再看看熔断策略配置的一些参数即可↓ @DefaultProperties可以不用,其实没那么复杂,用一个注解@HystrixCommand里面的两个属性来分别指定即可↓ 当然,别忘了引入hystrix熔断器依赖和用@SpringCloudApplication注解开启熔断器↓ 6.2.6 其他熔断策略配置,放最后讲,如果你不想配置,那就保持默认值↓ 熔断器命令默认配置策略配置记不住?,按shift键两次搜索打开HystrixCommandProperties类查看一下就知道↓ 消费者,搜索hystrix命令属性类,查看对应的配置熔断策略,拷贝下来修修改改即可↑↓ # 消费者,搜索hystrix命令属性类,查看对应的配置熔断策略,拷贝下来修修改改即可,注意首字母小写↓： hystrix: command: default: circuitBreaker: # 强制打开熔断器 默认false关闭的。测试配置是否生效 forceOpen: false # 触发熔断错误比例阈值，默认值50%!!! errorThresholdPercentage: 50 # 熔断后休眠时长，默认值5秒,即睡眠5秒去看服务如果没有问题,熔断器由半开到关闭,恢复服务的访问 sleepWindowInMilliseconds: 10000 # 熔断触发最小请求次数，默认值是20,即请求访问服务,服务出现错误2次开始触发熔断全开 requestVolumeThreshold: 2 execution: isolation: thread: # 熔断降级超时设置，默认为1秒,即访问服务耗时超过1秒就服务降级 timeoutInMilliseconds: 2000 如果是properties文件,前面都是hystrix.command.default.,后面忘了抄下面即可,所以了忘了就对了↓ 测试第一个forceOpen和最后两个requestVolumeThreshold,timeoutInMilliseconds,其他全部搞定↑ (1)超时时间测试 a.修改user-provider的com.itheima.controller.UserController的findById方法，让它休眠3秒钟。 b.修改user-consumer的application.yml，设置超时时间5秒，此时不会熔断。 c.如果把超时时间改成2000，此时就会熔断。 (2)熔断触发最小请求次数测试 a.修改user-provider的com.itheima.controller.UserController,在方法中制造异常，代码如下： b.3次并发请求&lt;http://localhost:18082/consumer/1&gt;，会触发熔断 再次请求&lt;http://localhost:18082/consumer/2&gt;的时候，也会熔断，5秒钟会自动恢复。 并发请求建议使用jmeter工具。 6.3 小结 Hystrix的作用:用于隔离访问远程服务、第三方库、防止出现级联失败也就是雪崩效应。 理解雪崩效应: 1.微服务中，一个请求可能需要多个微服务接口才能实现，会形成复杂的调用链路。 2.如果某服务出现异常，请求阻塞，用户得不到响应，容器中线程不会释放，于是越来越多用户请求堆积，越来越多线程阻塞。 3.单服务器支持线程和并发数有限，请求如果一直阻塞，会导致服务器资源耗尽，从而导致所有其他服务都不可用，从而形成雪崩效应； 知道熔断器的3个状态以及3个状态的切换过程 1.Closed：关闭状态，所有请求正常访问 2.Open：打开状态，所有请求都会被降级。 Hystrix会对请求情况计数，当一定时间失败请求百分比达到阈(yu：四声)值(极限值)，则触发熔断，断路器完全关闭 默认失败比例的阈值是50%，请求次数最低不少于20次 3.Half Open：半开状态 Open状态不是永久的，打开一会后会进入休眠时间(默认5秒)。休眠时间过后会进入半开状态。 半开状态：熔断器会判断下一次请求的返回状况，如果成功，熔断器切回closed状态。如果失败，熔断器切回open状态。 threshold reached 到达阈(yu：四声)值 under threshold 阈值以下 能理解什么是线程隔离，什么是服务降级 1.线程隔离：是指Hystrix为每个依赖服务调用一个小的线程池，如果线程池用尽，调用立即被拒绝，默认不采用排队。 2.服务降级(兜底方法)：优先保证核心服务，而非核心服务不可用或弱可用。触发Hystrix服务降级的情况：线程池已满、请求超时。 能实现一个局部方法熔断案例 1.定义一个局部处理熔断的方法failBack() 2.在指定方法上使用@HystrixCommand(fallbackMethod = &quot;failBack&quot;)配置调用 能实现全局方法熔断案例 1.定义一个全局处理熔断的方法defaultFailBack() 2.在类上使用@DefaultProperties(defaultFallback = &quot;defaultFailBack&quot;)配置调用 3.在指定方法上使用@HystrixCommand ","link":"https://2050188619.github.io/post/di-1-tian-springcloud/"},{"title":"java概念和环境搭建","content":" 1.计算机组成 1.1硬件： 输入设备，输出设备，存储设备，处理器，显卡，声卡，机箱。 1.2软件： 1.2.1系统软件：windows,linux,mac,unix,dos。 1.2.2应用软件： B/S架构软件：通过浏览器访问应用软件。 优点：使用方便无需安装客户端，数据安全（数据存放在服务器中），升级方便，更新只需要刷新浏览器即可。 缺点：界面简陋，服务器压力大。 C/S架构软件： 优点：服务器压力小，界面比较精美。 缺点：必须安装客户端才能使用，每次更新客户端都需要跟着更新，数据安全稍低。 2.程序 程序是为了模拟现实世界，解决现实问题而编写的一系列有序指令集合。 3.编程开发 3.1开发语言：Java 3.1.1 java是一个跨平台的，面向对象的，强类型的，编译解释型语言。 3.1.2 java优点： 简单（有自动垃圾回收机制，有自动类型检查机制） 跨平台（java可以在多个系统上运行） 面向对象（贴合人类思维方式） 安全性高（有强大的自动类型检查机制） 3.1.3 语言执行机制 3.1.3.1 编译执行机制：将源文件编译成平台可以识别的机器码文件，如c,c++。 3.1.3.2 解释执行机制：将源文件交给不同平台的jvm解释执行。 3.1.3.3 编译解释机制：先将源文件编译成字节码文件，再将字节码文件交给不同平台的jvm解释执行。（优点：跨平台） 3.1.4 Java体系： JavaSE:java平台标准版，java核心语法。用作桌面应用程序。 JavaEE:java平台企业版，java企业级开发。用作面向Internet应用程序。 JavaME:java平台微型版，嵌入式或者手机端开发，如机顶盒和手机移动开发。 3.1.5 Java应用 1.作面向桌面应用程序. 2.面向internet应用程序. 3.用来作机顶盒,或手机移动端开发. 4.为大型企业提供解决方案. 5.学习大数据基础. 3.1.6 开发工具：记事本，notepad++,eclipse,myeclipse,idea。 3.1.7 java开发工具包，其中包括jvm,jre,编译器等等。 4.Java环境搭建 4.1:卸载软件:控制面板-&gt;程序和功能-&gt;选择要卸载软件右键卸载-&gt;手动删除残留的文件. 4.2:安装jdk步骤: 4.2.1:安装jdk,注意选择安装目录.eg:D:jdk1.8 - bin:存放java命令 - jre:java运行环境 - lib:存放Java所需的Jar包 - src.zip:存放Java源码包. &gt;&gt;4.2.2:安装jre,注意选择安装目录.eg:D:jdk1.8jre &gt;&gt;4.2.3:测试jdk是否安装好:cmd-&gt;进入dos系统-&gt;进入jdk安装目录\\bin-&gt;输入命令测试 - java -version - javac - java &gt;&gt;4.2.4:配置Java环境:让计算机在任何地方都可以识别Java命令. 选中我的计算机右键属性-&gt;高级系统配置-&gt;环境变量-&gt;系统变量配置 JAVA_HOME:D:\\jdk1.8 path:在path路径中开头%JAVA_HOME%\\bin; 部分电脑: classpath: .;%JAVA_HOME%\\lib\\dt.jar;%JAVA_HOME%\\lib\\tools.jar ","link":"https://2050188619.github.io/post/java-gai-nian-he-huan-jing-da-jian/"},{"title":"JAVA中&&和&、||和|的区别","content":"if(a==1 &amp;&amp; b==2) 这是说既要满足a=1,也要满足b=2; if(a==1 || b==2) 这是说只需要满足a=1,或者满足b=2; 而a &amp; b和 a | b是二进制的与或运算 &amp;同为1时为1，否则为0； | 同为0时为0，否则为1； 短路求值 int a=10,b=10; if((a=0)==0 || (b=20)==20){ } System.out.println(b); if((a=0)==0 | (b=20)==20){ } System.out.println(b); 为什么第一个输出的b没有改变，而第二个b改变了呢？ 正是因为短路求值的原因，在 || 之前已经为true时，那么后面将会进行短路，不再继续操作。 而 | 却不会进行短路。 ","link":"https://2050188619.github.io/post/java-gai-shu/"},{"title":"HelloWorld","content":"首先下载jdk，安装配置好环境后，新建一个Java文件，命名为HelloWorld。 win+R进入运行界面，输入cmd进入Widow命令提示符。 先用cd命令进入文件所在位置，输入javac HelloWorld.java 编译成功后再输入java HelloWorld即可运行程序 public class HelloWorld{ public static void main(String[] args){ System.out.println(&quot;HelloWorld&quot;); } } ","link":"https://2050188619.github.io/post/di-yi-ge-jie-mian/"},{"title":"MarkDown语法快速入门","content":"1.代码块： 这里是代码块展示 java 2.标题 # 1级标题 ## 2级标题 #### 4级标题 3.字体 //加粗 等不到天亮 //代码高亮显示 我是孙红雷 //删除线 被删除的文字 //斜体 斜体内容 4.引用 &gt; 作者： &gt;&gt; 作者： &gt;&gt;&gt; 作者： 作者： 作者： 作者： 5.分割线 --- *** 6.图片插入 //在线图片 ![]() //本地图片 7.超链接 []() 8.列表 //无需列表 -目录1 -目录2 -目录3 9.脚注 创建脚注如以下 [1] 学的是精华。 ↩︎ ","link":"https://2050188619.github.io/post/di-er-ge-jie-mian/"}]}